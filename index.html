<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="关注公众号「苦逼的码农」，获取更多原创文章，后台回复「礼包」送你一份特别的大礼包">
<meta property="og:type" content="website">
<meta property="og:title" content="帅地">
<meta property="og:url" content="https://iamshuaidi.github.io/index.html">
<meta property="og:site_name" content="帅地">
<meta property="og:description" content="关注公众号「苦逼的码农」，获取更多原创文章，后台回复「礼包」送你一份特别的大礼包">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="帅地">
<meta name="twitter:description" content="关注公众号「苦逼的码农」，获取更多原创文章，后台回复「礼包」送你一份特别的大礼包">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://iamshuaidi.github.io/"/>





  <title>帅地</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">帅地</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我的眼里只有学习</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iamshuaidi.github.io/2018/08/20/https的安全保卫战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="帅地">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/https的安全保卫战/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T15:33:23+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: 一文看懂https如何保证数据传输的安全性的<br>date: 2018-7-30<br>tags: [https]<br>categories: [计算机网络]</p>
<hr>
<p>大家都知道，在客户端与服务器数据传输的过程中，http协议的传输是不安全的，也就是一般情况下http是<strong>明文</strong>传输的。但https协议的数据传输是安全的，也就是说https数据的传输是经过加密。</p>
<p>在客户端与服务器这两个完全没有见过面的陌生人交流中，https是如何保证数据传输的安全性的呢？</p>
<p>下面我将带大家一步步了解https是如何加密才得以保证数据传输的安全性的。我们先把客户端称为小客，服务器称为小服。然后一步步探索在小客与小服的交流中（就是一方请求一方响应）,https是如何保证他们的交流不会被中间人窃听的。</p>
<h1 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1. 对称加密"></a>1. 对称加密</h1><p>假如现在小客与小服要进行一次私密的对话，他们不希望这次对话内容被其他外人知道。可是，我们平时的数据传输过程中又是明文传输的，万一被某个黑客把他们的对话内容给窃取了，那就难受了。  </p>
<p>为了解决这个问题，小服这家伙想到了一个方法来<strong>加密</strong>数据，让黑客看不到具体的内容。该方法是这样子的：  </p>
<p>在每次数据传输之前，小服会先传输小客一把密钥，然后小服在之后给小客发消息的过程中，会用这把密钥对这些消息进行<strong>加密</strong>。小客在收到这些消息后，会用之前小服给的那把<strong>密钥</strong>对这些消息进行<strong>解密</strong>，这样，小客就能得到密文里面真正的数据了。如果小客要给小服发消息，也同样用这把<strong>密钥</strong>来对消息进行加密，小服收到后也用这把密钥进行解密。  这样，就保证了数据传输的安全性。如图所示:</p>
<p><img src="https://i.imgur.com/GSoVDgS.png" alt=""></p>
<p>这时，小服想着自己的策咯，还是挺得意的。</p>
<p>可是，这时候问题来了。这个策略安全的前提是，小客拥有小服的那把密钥。可问题是，小服是以明文的方式把这把密钥传输给小客的，这个时候，如果黑客截取了这把密钥，那就难受了。小服与小客就算是加密了内容，在截取了密钥的黑客老哥眼里，这和明文没啥区别。  </p>
<h1 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2. 非对称加密"></a>2. 非对称加密</h1><p>小服还是挺聪明的，得意了一会之后，小服意识到了密钥会被截取这个问题。倔强的小服又想到了另外一种方法：用<strong>非对称加密</strong>的方法来加密数据。该方法是这样的：</p>
<p>小服和小客都拥有两把钥匙，一把钥匙的公开的（全世界都知道也没关系），称之为<strong>公钥</strong>；而另一把钥匙是保密（也就是只有自己才知道），称之为<strong>私钥</strong>。并且，<strong>用公钥加密的数据，只有对应的私钥才能解密；用私钥加密的数据，只有对应的公钥才能解密。</strong></p>
<p>所以在传输数据的过程中，小服在给小客传输数据的过程中，会用小客给他的<strong>公钥</strong>进行加密，然后小客收到后，再用自己的<strong>私钥</strong>进行解密。小客给小服发消息的时候，也一样会用小服给他的公钥进行加密，然后小服再用自己的私钥进行解密。    这样，数据就能安全着到达双方。如图：</p>
<p><img src="https://i.imgur.com/aIktIxY.png" alt=""></p>
<p>想着这么复杂的策略都能想出来，小服可是得意的不能在得意了…..</p>
<p>看着那么得意的小服，小客这时心情就不得好了。还没等小服得意多久，小客就给它泼了一波冷水了。</p>
<p>小客严肃着说：其实，你的这种方法也不是那么的安全啊。还是存在被黑客截取的危险啊。例如：</p>
<p>你在给我传输公钥的过程中，如果黑客截取了你的公钥，并且拿着自己的公钥来<strong>冒充你的公钥</strong>来发给我。我收到公钥之后，会用公钥进行加密传输（这时用的公钥实际上是黑客的公钥）。黑客截取了加密的消息之后，可以用<strong>他自己的私钥</strong>来进行解密来获取消息内容。然后在用你（小服）的公钥来对消息进行加密，之后再发给你（小服）。 这样子，我们的对话内容还是被黑客给截取了啊。（倒过来小客给小服传输公钥的时候也一样）。</p>
<p>我靠，这么精妙的想法居然也不行，小服这波，满脸无神。 </p>
<h2 id="插讲下"><a href="#插讲下" class="headerlink" title="插讲下"></a>插讲下</h2><p>其实在传输数据的过程中，在速度上用<strong>对称加密</strong>的方法会比<strong>非对称加密</strong>的方法快很多。所以在传输数据的时候，一般不单单只用非对称加密这种方法(我们先假设非对称密码这种方法很安全)，而是会用<strong>非对称加密 + 对称加密</strong>这两种结合的方法。  你想啊，对于对称加密这种方法来说，之所以不安全是因为<strong>密钥</strong>在传输的过程中，被别人知道了。基于这个，我们可以用<strong>非对称加密</strong>方法来安全着传输<strong>密钥</strong>，之后在用对称加密的方法来传输消息内容（当然，我这里假定了非对称加密传输是安全的，下面会讲如何使之安全）。</p>
<h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>我们回头想一下，是什么原因导致<strong>非对称加密</strong>这种方法的不安全性呢？它和<strong>对称加密</strong>方法的不安全性不同。非对称加密之所以不安全，是因为小客收到了公钥之后，无法确定这把公钥是否真的是小服。</p>
<p>也就是说，我们需要找到一种策略来证明这把公钥就是小服的，而不是别人冒充的。</p>
<p>为了解决这个问题，小服和小客通过绞尽脑汁想出了一种终极策略：<strong>数字证书</strong>：</p>
<p>我们需要找到一个拥有公信力、大家都认可的<strong>认证中心(CA)</strong></p>
<p>小服再给小客发公钥的过程中，会把公钥以及小服的个人信息通过<strong>Hash算法</strong>生成<strong>消息摘要</strong>。如图：</p>
<p><img src="https://i.imgur.com/nySQRa4.png" alt=""></p>
<p>为了防止摘要被人调换，小服还会用<strong>CA提供的私钥</strong>对消息摘要进行加密来形成数字签名。如图：</p>
<p><img src="https://i.imgur.com/gLTxMqb.png" alt=""></p>
<p>并且，最后还会把原来没Hash算法之前的信息和数字签名合并在一起，形成<strong>数字证书</strong>。如图：</p>
<p><img src="https://i.imgur.com/Rzla3Se.png" alt=""></p>
<p>当小客拿到这份数字证书之后，就会用<strong>CA提供的公钥</strong>来对数字证书里面的<strong>数字签名</strong>进行解密得到<strong>消息摘要</strong>，然后对数字证书里面<strong>小服的公钥和个人信息</strong>进行Hash得到另一份<strong>消息摘要</strong>，然后把两份消息摘要进行对比，如果一样，则证明这些东西确实是小服的，否则就不是。如图：</p>
<p><img src="https://i.imgur.com/UYXxm0g.png" alt=""></p>
<p>这时可能有人会有疑问，CA的公钥是怎么拿给小客的呢？小服又怎么有CA的私钥呢？其实，(有些)服务器在一开始就向认证中心申请了这些证书，而客户端里，也会内置这些证书。如图(此图来元阮一峰的网络日志)</p>
<p><img src="https://i.imgur.com/0CVqeGc.png" alt=""></p>
<p>当客户端收到服务器返回来的数据时，就会在内置的证书列表里，查看是否有有解开该数字证书的公钥，如果有则…..否则…..</p>
<p>讲到这里，就大概结束了。希望对你有所帮助勒。如果有哪里写得不对的地方，欢迎大家指出。</p>
<p>推荐阅读：</p>
<p><a href="https://juejin.im/post/5b5a7be96fb9a04fa7755e9e" target="_blank" rel="noopener">一文读懂一台计算机是如何把数据传送给另外一台计算机的</a></p>
<p>一文带你简要了解https是如何保证数据传输的安全性的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iamshuaidi.github.io/2018/08/20/线程安全(上)--彻底搞懂volatile关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="帅地">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/线程安全(上)--彻底搞懂volatile关键字/" itemprop="url">线程安全(上)--彻底搞懂volatile关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T00:00:00+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于volatile这个关键字，相信很多朋友都听说过，甚至使用过，这个关键字虽然字面上理解起来比较简单，但是要用好起来却不是一件容易的事。</p>
<p>这篇文章将从多个方面来讲解volatile，让你对它更加理解。</p>
<h2 id="计算机中为什么会出现线程不安全的问题"><a href="#计算机中为什么会出现线程不安全的问题" class="headerlink" title="计算机中为什么会出现线程不安全的问题"></a>计算机中为什么会出现线程不安全的问题</h2><p>volatile既然是与线程安全有关的问题，那我们先来了解一下计算机在处理数据的过程中为什么会出现线程不安全的问题。</p>
<p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中会涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。</p>
<p>为了处理这个问题，在CPU里面就有了高速缓存(Cache)的概念。当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>
<p>我举个简单的例子，比如cpu在执行下面这段代码的时候,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = t + 1;</span><br></pre></td></tr></table></figure>
<p>会先从高速缓存中查看是否有t的值，如果有，则直接拿来使用，如果没有，则会从主存中读取，读取之后会复制一份存放在高速缓存中方便下次使用。之后cup进行对t加1操作，然后把数据写入高速缓存，最后会把高速缓存中的数据刷新到主存中。</p>
<p>这一过程在单线程运行是没有问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的，本次讲解以多核cup为主）。这时就会出现同一个变量在两个高速缓存中的<strong>值</strong>不一致问题了。</p>
<p>例如：</p>
<p>两个线程分别读取了t的值，假设此时t的值为0，并且把t的值存到了各自的高速缓存中，然后线程1对t进行了加1操作，此时t的值为1，并且把t的值写回到主存中。但是线程2中高速缓存的值还是0，进行加1操作之后，t的值还是为1，然后再把t的值写回主存。</p>
<p>此时，就出现了线程不安全问题了。</p>
<h2 id="Java中的线程安全问题"><a href="#Java中的线程安全问题" class="headerlink" title="Java中的线程安全问题"></a>Java中的线程安全问题</h2><p>上面那种线程安全问题，可能对于不同的操作系统会有不同的处理机制，例如Windows操作系统和Linux的操作系统的处理方法可能会不同。</p>
<p>我们都知道，Java是一种夸平台的语言，因此Java这种语言在处理线程安全问题的时候，会有自己的处理机制，例如volatile关键字，synchronized关键字，并且这种机制适用于各种平台。</p>
<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>由于java中的每个线程有自己的工作空间，这种工作空间相当于上面所说的高速缓存，因此多个线程在处理一个<strong>共享变量</strong>的时候，就会出现线程安全问题。</p>
<blockquote>
<p>这里简单解释下<strong>共享变量</strong>，上面我们所说的t就是一个共享变量，也就是说，能够被多个线程访问到的变量，我们称之为共享变量。在java中共享变量包括实例变量，静态变量，数组元素。他们都被存放在堆内存中。</p>
</blockquote>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>上面扯了一大堆，都没提到volatile关键字的作用，下面开始讲解volatile关键字是如何保证线程安全问题的。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><h5 id="什么是可见性？"><a href="#什么是可见性？" class="headerlink" title="什么是可见性？"></a>什么是可见性？</h5><p>意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的<strong>工作空间</strong>中读取</p>
<p>例如我们上面说的，当线程1对t进行了加1操作并把数据写回到主存之后，线程2就会知道它自己工作空间内的t已经被修改了，当它要执行加1操作之后，就会去主存中读取。这样，两边的数据就能一致了。</p>
<p>假如一个变量被声明为volatile，那么这个变量就具有了<strong>可见性</strong>的性质了。这就是volatile关键的作用之一了。</p>
<h5 id="volatile保证变量可见性的原理"><a href="#volatile保证变量可见性的原理" class="headerlink" title="volatile保证变量可见性的原理"></a>volatile保证变量可见性的原理</h5><p>当一个变量被声明为volatile时，在编译成会变指令的时候，会多出下面一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00bbacde: lock add1 $0x0,(%esp);</span><br></pre></td></tr></table></figure>
<p>这句指令的意思就是在寄存器执行一个加0的空操作。不过这条指令的前面有一个lock(锁)前缀。</p>
<p>当处理器在处理拥有lock前缀的指令时：</p>
<p>在之前的处理中，lock会导致传输数据的总线被锁定，其他处理器都不能访问总线，从而保证处理lock指令的处理器能够独享操作数据所在的内存区域，而不会被其他处理所干扰。</p>
<p>但由于总线被锁住，其他处理器都会被堵住，从而影响了多处理器的执行效率。为了解决这个问题，在后来的处理器中，处理器遇到lock指令时不会再锁住总线，而是会检查数据所在的内存区域，如果该数据是在处理器的内部缓存中，则会锁定此缓存区域，处理完后把缓存写回到主存中，并且会利用<strong>缓存一致性协议</strong>来保证其他处理器中的缓存数据的一致性。</p>
<h5 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h5><p>刚才我在说可见性的时候，说“如果一个共享变量被一个线程修改了之后，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的<strong>工作空间</strong>中读取”，实际上是这样的：</p>
<p>线程中的处理器会一直在总线上嗅探其内部缓存中的内存地址在其他处理器的操作情况，一旦嗅探到某处处理器打算修改其内存地址中的值，而该内存地址刚好也在自己的内部缓存中，那么处理器就会强制让自己对该缓存地址的无效。所以当该处理器要访问该数据的时候，由于发现自己缓存的数据无效了，就会去主存中访问。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>实际上，当我们把代码写好之后，虚拟机不一定会按照我们写的代码的顺序来执行。例如对于下面的两句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br></pre></td></tr></table></figure>
<p>对于这两句代码，你会发现无论是先执行a = 1还是执行b = 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行<strong>重排序</strong>的。</p>
<p>为什么要进行重排序呢？</p>
<p>你想啊，假如执行 int a = 1这句代码需要100ms的时间，但执行int b = 2这句代码需要1ms的时间，并且先执行哪句代码并不会对a,b最终的值造成影响。那当然是先执行int b = 2这句代码了。</p>
<p>所以，虚拟机在进行代码编译优化的时候，对于那些改变顺序之后不会对最终变量的值造成影响的代码，是有可能将他们进行重排序的。</p>
<p>更多代码编译优化可以看我写的另一篇文章：<br><a href="https://mp.weixin.qq.com/s/NHBSv6AmpsKTZPmhj_sU6A" target="_blank" rel="noopener">虚拟机在运行期对代码的优化策略</a></p>
<p>那么重排序之后真的不会对代码造成影响吗？</p>
<p>实际上，对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全问题的。具体请看下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class NoVisibility&#123;</span><br><span class="line">    private static boolean ready;</span><br><span class="line">    private static int number;</span><br><span class="line">    </span><br><span class="line">    private static class Reader extends Thread&#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">        while(!ready)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(number);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Reader().start();</span><br><span class="line">        number = 42;</span><br><span class="line">        ready = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码最终打印的一定是42吗？如果没有重排序的话，打印的确实会是42，但如果number = 42和ready = true被进行了重排序，颠倒了顺序，那么就有可能打印出0了，而不是42。（因为number的初始值会是0).</p>
<p>因此，重排序是有可能导致线程安全问题的。</p>
<p>如果一个变量被声明volatile的话，那么这个变量不会被进行重排序，也就是说，虚拟机会保证这个变量之前的代码一定会比它先执行，而之后的代码一定会比它慢执行。</p>
<p>例如把上面中的number声明为volatile，那么number = 42一定会比ready = true先执行。</p>
<blockquote>
<p>不过这里需要注意的是，虚拟机只是保证这个变量之前的代码一定比它先执行，但并没有保证这个变量之前的代码不可以重排序。之后的也一样。</p>
</blockquote>
<p>volatile关键字能够保证代码的<strong>有序性</strong>，这个也是volatile关键字的作用。</p>
<p>总结一下，一个被volatile声明的变量主要有以下两种特性保证保证线程安全。</p>
<ol>
<li>可见性。</li>
<li>有序性。</li>
</ol>
<h4 id="volatile真的能完全保证一个变量的线程安全吗？"><a href="#volatile真的能完全保证一个变量的线程安全吗？" class="headerlink" title="volatile真的能完全保证一个变量的线程安全吗？"></a>volatile真的能完全保证一个变量的线程安全吗？</h4><p>我们通过上面的讲解，发现volatile关键字还是挺有用的，不但能够保证变量的可见性，还能保证代码的有序性。</p>
<p>那么，它真的能够保证一个变量在多线程环境下都能被正确的使用吗？</p>
<p>答案是否定的。原因是因为Java里面的运算并非是<strong>原子操作</strong>。</p>
<h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p><strong>原子操作</strong>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>也就是说，处理器要嘛把这组操作全部执行完，中间不允许被其他操作所打断，要嘛这组操作不要执行。</p>
<p>刚才说Java里面的运行并非是原子操作。我举个例子，例如这句代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = b + 1;</span><br></pre></td></tr></table></figure>
<p>处理器在处理代码的时候，需要处理以下三个操作：</p>
<ol>
<li>从内存中读取b的值。</li>
<li>进行a = b + 1这个运算</li>
<li>把a的值写回到内存中</li>
</ol>
<p>而这三个操作处理器是不一定就会连续执行的，有可能执行了第一个操作之后，处理器就跑去执行别的操作的。</p>
<h5 id="证明volatile无法保证线程安全的例子"><a href="#证明volatile无法保证线程安全的例子" class="headerlink" title="证明volatile无法保证线程安全的例子"></a>证明volatile无法保证线程安全的例子</h5><p>由于Java中的运算并非是原子操作，所以导致volatile声明的变量无法保证线程安全。</p>
<p>对于这句话，我给大家举个例子。代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static volatile int t = 0;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    </span><br><span class="line">        Thread[] threads = new Thread[10];</span><br><span class="line">        for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">            //每个线程对t进行1000次加1的操作</span><br><span class="line">            threads[i] new Thread(new Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    for(int j = 0; j &lt; 1000; j++)&#123;</span><br><span class="line">                        t = t + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //等待所有累加线程都结束</span><br><span class="line">        while(Thread.activeCount() &gt; 1)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //打印t的值</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的打印结果会是1000 * 10 = 10000吗？答案是否定的。</p>
<p>问题就出现在t = t + 1这句代码中。我们来分析一下</p>
<p>例如：</p>
<p>线程1读取了t的值，假如t = 0。之后线程2读取了t的值，此时t = 0。</p>
<p>然后线程1执行了加1的操作，此时t = 1。但是这个时候，处理器还没有把t = 1的值写回主存中。这个时候处理器跑去执行线程2，注意，刚才线程2已经读取了t的值，所以这个时候并不会再去读取t的值了，所以此时t的值还是0，然后线程2执行了对t的加1操作，此时t =1 。</p>
<p>这个时候，就出现了线程安全问题了，两个线程都对t执行了加1操作，但t的值却是1。所以说，volatile关键字并不一定能够保证变量的安全性。</p>
<h4 id="什么情况下volatile能够保证线程安全"><a href="#什么情况下volatile能够保证线程安全" class="headerlink" title="什么情况下volatile能够保证线程安全"></a>什么情况下volatile能够保证线程安全</h4><p>刚才虽然说，volatile关键字不一定能够保证线程安全的问题，其实，在大多数情况下volatile还是可以保证变量的线程安全问题的。所以，在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：</p>
<ol>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他状态变量共同参与不变约束。</li>
</ol>
<p>讲到这里，关于volatile关键字的就算讲完了。如果有哪里讲的不对的地方，非常欢迎你的指点。下篇应该会讲synchronize关键字。</p>
<p><strong>完</strong></p>
<p>参考书籍：</p>
<ol>
<li>深入理解Java虚拟机(JVM高级特性与最佳实践)。</li>
<li>Java并非编程实战</li>
</ol>
<blockquote>
<p>关注公众号：<strong>苦逼的码农</strong>，获取更多原创文章，后台回复”礼包”送你一份资源大礼包。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iamshuaidi.github.io/2018/08/19/关于我：一名双非的小混混/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="帅地">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/19/关于我：一名双非的小混混/" itemprop="url">关于我：一名来自双非学校的小混混</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-19T00:00:00+08:00">
                2018-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/me/" itemprop="url" rel="index">
                    <span itemprop="name">me</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>玩公众号有一两个月了，还没介绍过自己，这篇文章简单介绍下自己。</p>
<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><p>本人姓<strong>林</strong>，名<strong>秋地</strong>，自称<strong>帅地</strong>，就读于广州某双非大学，专业是软件工程，现在是准大三，热爱编程。不过大一读的专业是与编程无关的，之后转专业到软件工程来，从此陷入码农的世界无法自拔。</p>
<p>刚到软件工程那会，感觉打acm特别有意思，心里对acm比赛充满了兴趣。于是买了各种算法的书籍，也去各大网站刷题。后来刷着刷着，说真的，那些题对于我来说，是真的难啊。一道题做了几个小时，有些题看答案也看了几个小时，没研究几道题一天就过去了。</p>
<p>慢慢着，发现自己并不适合打acm，加上自己参加那些牛客网什么的月赛和周周练之类的，每次都做的不大理想，于是就果断放弃打acm了，跑去好好学习其他技术。</p>
<h3 id="写作历程"><a href="#写作历程" class="headerlink" title="写作历程"></a>写作历程</h3><p>之所以会选择写作，主要是基于以下原因：</p>
<ol>
<li>用在刷题的时间少了，自然也就多了一些时间。个人也比较喜欢上各种博客论坛逛，在论坛里经常是只看不输出，慢慢着，萌生了去尝试写文章的想法。</li>
<li>从小就害怕写作文，看到一个自己心里挺懂的问题，但想要用语言把自己的想法有条理着描述出来，每次都把文字组织的很混乱。于是，也有点想去写文章锻炼一下自己的写作能力。</li>
<li>每次看技术书籍都看到很快，总觉得自己理解了，但每次要用的时候，发现忘了一干二净，然后经常听大佬们说，输出很重要</li>
<li>…..</li>
</ol>
<p>基于以上等原因，我开始了我的第一次写作。</p>
<p>最开始我是在CDNS写的文章。说真的，对于新手来说，写文章真的是太花时间了，一篇简单的文章，都能让我写四五个小时，而且写了之后也没啥人看。心想，要是我拿这四五个小时去看书，不知道还得看多少页的书呢。</p>
<p>大概写了几篇吧，就没去写了。<strong>写原创文章</strong>真的好累。</p>
<p>然后又过了几个月，心里又萌生了坚持把文章写下去的想法，加上在<strong>张哥</strong>(stormzhang)(不要告诉我你不知道<strong>帅张</strong>）的公众号里也一直强调未来写作的重要性，于是自己就真的想逼自己一把，坚持写下去。于是这次就搞了个公众号来写文章记录自己的学习历程。</p>
<p>说真的，自从关注了张哥的公众号之后，收获了不少思想层面上的东西，再次真的非常谢谢张哥。（张哥的公众号：stormzhang)</p>
<p>希望自己能够一直坚持下去…..</p>
<h3 id="写作内容"><a href="#写作内容" class="headerlink" title="写作内容"></a>写作内容</h3><p>我的专业是软件工程，并且我现在主要用的语言是Java，所以分享的内容包括：</p>
<ol>
<li>计算机网络。</li>
<li>数据库。</li>
<li>操作系统。</li>
<li>java相关的技术体系。</li>
<li>数据结构与算法。</li>
<li>Linux。</li>
</ol>
<p>主要是自己一边学习，把所学的，感觉比较不错的，会用自己的理解写出来。</p>
<p>自己发现leetcode这个网站的题挺不错，而且感觉相比其他网站的题会容易一点，大佬们也经常建议把里面的题都过一遍。所以写作的内容也会分享在leetcode的刷题贴。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>现在是准大三，毕业后的目标是bat等公司，虽然有点难。但，并非没机会。欢迎你的关注，与我一起成长。</p>
<p><strong>完</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iamshuaidi.github.io/2018/08/15/聊一聊让我蒙蔽一晚上的各种常量池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="帅地">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/聊一聊让我蒙蔽一晚上的各种常量池/" itemprop="url">聊一聊让我蒙蔽一晚上的各种常量池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-15T00:00:00+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在写之前我们先来看几个问题，假如你对这些问题已经很懂了的话，那大可不用看这篇文章，如果不大懂的话，那么可以看看我的想法。</p>
<p>问题1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    String t1 = new String(&quot;2&quot;);</span><br><span class="line">    t1.intern();</span><br><span class="line">    String t2 = &quot;2&quot;;</span><br><span class="line">    System.out.println(t1 == t2);</span><br><span class="line">    </span><br><span class="line">    String t3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class="line">    t3.intern();</span><br><span class="line">    String t4 = &quot;22&quot;;</span><br><span class="line">    System.out.println(t3 == t4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案输出：</p>
<p>JDK1.6是 false false</p>
<p>JDK1.7是 false true;</p>
<p>问题2(把问题1的语句调换一下位置)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    String t1 = new String(&quot;2&quot;);</span><br><span class="line">    String t2 = &quot;2&quot;;</span><br><span class="line">    t1.intern();</span><br><span class="line">    System.out.println(t1 == t2);</span><br><span class="line">    </span><br><span class="line">    String t3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class="line">    String t4 = &quot;22&quot;;</span><br><span class="line">    t3.intern();</span><br><span class="line">    System.out.println(t3 == t4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案输出：<br>false false</p>
<p>对于这两个问题，看了几个人的博客，可谓百花齐放，越看越懵逼</p>
<p>问题3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    Integer a = 1;</span><br><span class="line">    Integer b = 2;</span><br><span class="line">    Integer c = 3;</span><br><span class="line">    Integer d = 3;</span><br><span class="line">    Integer e = 321;</span><br><span class="line">    Integer f = 321;</span><br><span class="line">    Long g = 3L;</span><br><span class="line">    </span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">    System.out.Println(e == f);</span><br><span class="line">    System.out.println(c == (a + b));</span><br><span class="line">    System.out.println(c.equals(a+b));</span><br><span class="line">    System.out.println(g == (a + b));</span><br><span class="line">    System.out.println(g.equals(a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案输出：</p>
<p>true</p>
<p>false</p>
<p>true</p>
<p>true</p>
<p>true</p>
<p>false</p>
<p>问题4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行时常量池与字符串常量池是什么关系？包含？</span><br></pre></td></tr></table></figure>
<p>在解决问题之前，我们先来简单了解一些常量池的一些知识点(大部分来源于周志明的深入Java虚拟机这本书)。</p>
<h3 id="JVM中的几种常量池"><a href="#JVM中的几种常量池" class="headerlink" title="JVM中的几种常量池"></a>JVM中的几种常量池</h3><h4 id="1-class文件常量池"><a href="#1-class文件常量池" class="headerlink" title="1.class文件常量池"></a>1.class文件常量池</h4><p>在Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池(Constant Pool Table)</strong>，用于存放编译期生成的各种字面量和符号引用。</p>
<p>这里简单解释下字面量和符号引用</p>
<p><strong>字面量</strong></p>
<p>字面量类似与我们平常说的常量，主要包括：</p>
<ol>
<li>文本字符串：就是我们在代码中能够看到的字符串，例如String a = “aa”。其中”aa”就是字面量。</li>
<li>被final修饰的变量。</li>
</ol>
<p><strong>符号引用</strong></p>
<p>主要包括以下常量：</p>
<ol>
<li>类和接口和全限定名：例如对于String这个类，它的全限定名就是java/lang/String。</li>
<li>字段的名称和描述符：所谓字段就是类或者接口中声明的变量，包括类级别变量（static)和实例级的变量。</li>
<li>方法的名称和描述符。所谓描述符就相当于方法的<strong>参数类型+返回值类型</strong>。</li>
</ol>
<h4 id="2-运行时常量池"><a href="#2-运行时常量池" class="headerlink" title="2.运行时常量池"></a>2.运行时常量池</h4><p>我们上面说的class文件中的常量池，它会在类加载后进入<strong>方法区</strong>中的运行时常量池。并且需要的注意的是，运行时常量池是全局共享的，多个类共用一个运行时常量池。并且class文件中常量池多个相同的字符串在运行时常量池只会存在一份。</p>
<p>注意运行时常量池存在于<strong>方法区</strong>中。</p>
<h4 id="3-字符串常量池"><a href="#3-字符串常量池" class="headerlink" title="3.字符串常量池"></a>3.字符串常量池</h4><p>看名字我们就可以知道字符串常量池会用来存放<strong>字符串</strong>，也就是说常量池中的文本字符串会在类加载时进入字符串常量池。</p>
<p>那字符串常量池和运行时常量池是什么关系呢？上面我们说常量池中的字面量会在类加载后进入运行时常量池，其中字面量中有包括文本字符串，显然从这段文字我们可以知道字符串常量池存在于运行时常量池中。也就存在于<strong>方法区</strong>中。</p>
<p>不过在周志明那本深入java虚拟机中有说到，到了JDK1.7时，字符串常量池就被移出了方法区，转移到了<strong>堆</strong>里了。</p>
<p>那么我们可以推断，到了JDK1.7以及之后的版本中，运行时常量池并没有包含字符串常量池，运行时常量池存在于方法区中，而字符串常量池存在于<strong>堆</strong>中。</p>
<p>说了这么多，现在我们开始来解决上面提出了问题。</p>
<h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>问题1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    String t1 = new String(&quot;1&quot;);</span><br><span class="line">    t1.intern();</span><br><span class="line">    String t2 = &quot;1&quot;;</span><br><span class="line">    System.out.println(t1 == t2);</span><br><span class="line">    </span><br><span class="line">    String t3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class="line">    t3.intern();</span><br><span class="line">    String t4 = &quot;22&quot;;</span><br><span class="line">    System.out.println(t3 == t4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案输出：</p>
<p>JDK1.6是 false false。</p>
<p>JDK1.7是 false true;</p>
<p>在解决这个问题之前，我们先来看另外一道面试中经常会问到的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String t = new String(&quot;tt&quot;);</span><br></pre></td></tr></table></figure>
<p>假如程序中只有这样一行代码，那么这行代码创建了几个对象？</p>
<p>我们上面说过，”tt”属于字面量，那么它会在类加载之后存在于字符串常量池中，也就是说，在 String t = new String(“tt”)这句代码执行之前，字符串常量池就已经创建了”tt”这个字符串对象了，我们都知道，new这个关键字会在堆中创建一个对象。</p>
<p>所以，这段代码创建了两个对象。一个在堆中，一个在字符串常量池中。</p>
<p>那么下面这段代码又是创建了几个对象呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String t1 = new String(&quot;tt&quot;);</span><br><span class="line">String t2 = new String(&quot;tt&quot;);</span><br></pre></td></tr></table></figure>
<p>答是这段代码创建了三个对象，我们上面说了，字符串常量池只会保存一份内容相同的字符串。也就是说，在这两句代码执行之前，字符串常量池就已经创建了内容为”tt”的对象了。这两句代码执行之后，又在堆中创建了两个，所以一共创建了三个。</p>
<p>那么下面这段代码又是创建了几个对象？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String t = &quot;tt&quot;;</span><br></pre></td></tr></table></figure>
<p>答是1个，在这段代码执行之前，字符串常量池已经创建了一个”tt”的对象，但由于这行代码并非用new的方法，所以虚拟机会在字符串常量池中寻找是否有内容为”tt”的字符串对象，如果有，则直接返回这个字符串的引用，所以最终结果只创建了一个对象。</p>
<p>回到我们的问题，在这里我们先<strong>解释下String 的intern方法</strong>。</p>
<p>例如我们调用了t.intern()。</p>
<p>在JDK1.6的时候，调用了这个方法之后，虚拟机会在字符串常量池在查找是否有内容与”tt”相等的对象，如果有，则返回这个对象，如果没有，则会在字符串常量池中<strong>添加</strong>这个对象。注意，是把这个对象添加到字符串常量池。</p>
<p>到了JDK1.7之后，如果调用了intern这个方法，虚拟机会在字符串常量池在查找是否有内容与”tt”相等的对象，如果有，则返回这个对象，如果没有。则会在堆中把这个对象的<strong>引用</strong>复制添加到字符串常量池中。注意，这个时候添加的是对象在堆中的引用。</p>
<p><strong>现在开始来分析问题中的代码</strong></p>
<p>t1 = new String(“1”)。</p>
<p>这句代码执行之前，字符串常量池中已经有”t”这个对象，执行之后会在堆中也创建一个”t”的对象，<strong>此时t1指向的是堆中的对象</strong>。</p>
<p>t1.intern();</p>
<p>这句代码执行之后，会在字符串常量池寻早内容为”t”的对象，字符串常量池已经存在这个对象了，把这个对象返回(不过返回之后并没有变量来接收)。</p>
<p>t2 = “1”。</p>
<p>这句执行后会在字符串常量池查找内容为”t”的对象，字符串常量池已经有这个对象了，返回给t2，<strong>此时t2指向的是常量池中的对象</strong>。</p>
<p>一个是常量池中的对象，一个是在堆中的对象，两者能相等吗？因此</p>
<p>t1 与 t2不相等。</p>
<p><strong>接着下面</strong></p>
<p>t3 = new String(“2”) + new String(“2”);</p>
<p>这段代码调用之前，字符串常量池有一个”2”的对象，执行之后，实际上会调用StringBuilder的append()方法类进行拼接，最后在堆中创建一个”22”的对象，注意，此时<strong>字面量</strong>并没有”22”这个字符串，也就是说在字符串常量池并没有”22”这个对象。<strong>此时t3指向堆中”22”这个对象</strong></p>
<p>t3.intern();</p>
<p>执行这个方法之后</p>
<p><strong>在JDK1.6的时候</strong>，它在字符串常量池中并没有找到内容为”22”的对象，所以这个时候会把这个<strong>对象添加到字符串常量池</strong>，并把这个对象返回(此时并没有变量来接收这个返回的对象)。注意添加的是对象，而并非引用。</p>
<p>t4 = “22”。</p>
<p>这句代码执行后，会返回字符串常量池中内容为”22”对象，<strong>此时t4指向的是字符串常量池中的对象</strong>。</p>
<p>显然，一个对象在字符串常量池，一个在堆中，两个对象并非是同一个对象，因此在JDK1.6的时候，t3与t4不相等。</p>
<p><strong>但是在JDK1.7的时候</strong></p>
<p>t3.intern()执行之后，由于在字符串常量池在并没有内容为”22”的对象，所以会把堆中该对象的引用赋值到字符串常量池。注意此时字符串常量池保存的是<strong>堆中这个对象的引用</strong>。</p>
<p>t4 = “22”。</p>
<p>执行这句代码之后，从字符串常量池返回给t4的是<strong>堆中对象的引用</strong>。此时t4指向的实际上是堆中对象的引用，也就是说，t3和t4指向的是同一个对象。</p>
<p>因此t3与t4相等。</p>
<p>不知道你明白了没有？反正我是搞了好久才明白…</p>
<h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>至于问题2，我就只讲下半部分的代码，上半部分如果你看懂了问题1，那么问题2也差不多自然懂了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String t3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class="line">String t4 = &quot;22&quot;;</span><br><span class="line">t3.intern();</span><br><span class="line">System.out.println(t3 == t4);</span><br></pre></td></tr></table></figure>
<p>t3 = new String(“2”) + new String(“2”)。</p>
<p>这段代码调用之前，字符串常量池有一个”2”的对象，执行之后，实际上会调用StringBuilder的append()方法类进行拼接，最后在堆中创建一个”22”的对象。<strong>此时t3指向堆中”22”这个对象</strong></p>
<p>t4 = “22”。</p>
<p>这句代码执行之前，字符串常量池已经存在”22”这个对象了，所有直接把这个对象返回给t4，<strong>此时t4指向的是字符串常量池中的对象</strong>.</p>
<p>所以t3和t4肯定不是同一个对象啊，t3.intern这句几乎可以忽略，不会给t3和t4造成任何影响。</p>
<h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    Integer a = 1;</span><br><span class="line">    Integer b = 2;</span><br><span class="line">    Integer c = 3;</span><br><span class="line">    Integer d = 3;</span><br><span class="line">    Integer e = 321;</span><br><span class="line">    Integer f = 321;</span><br><span class="line">    Long g = 3L;</span><br><span class="line">    </span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">    System.out.Println(e == f);</span><br><span class="line">    System.out.println(c == (a + b));</span><br><span class="line">    System.out.println(c.equals(a+b));</span><br><span class="line">    System.out.println(g == (a + b));</span><br><span class="line">    System.out.println(g.equals(a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个问题，我简单说一下可能你就懂了。</p>
<p>(1). 内存中有一个java基本类型封装类的常量池。这些类包括<br>Byte, Short, Integer, Long, Character, Boolean。需要注意的是，Float和Double这两个类并没有对应的常量池。</p>
<p>(2).上面5种整型的包装类也只是在对象数值在-128~127才可以使用这些常量池。</p>
<p>(3). 在周志明的那本虚拟机中有这样一句话：包装类的<br>“\==”运行符在不遇到算术运算的情况下不会自动<strong>拆箱</strong>，以及他们的equals()方法不处理数据类型的关系，可以推断出如果遇到“==”两边有算术运算是话就会自动拆箱和进行数据类型转换处理。</p>
<p>(4).Long的equals方法会先判断是否是Long类型。</p>
<p>(5).无论是Integer还是Long，他们的equals方法比较的是数值。</p>
<p>所以：</p>
<p>System.out.println(c == d)。</p>
<p>由于常量池的作用，c与d指向的是同一个对象(注意此时的==比较的是对象，也就是地址，而不是数值)。因此为true</p>
<p>System.out.println(e == f)。</p>
<p>由于321超过了127，因此常量池失去了作用，所以e和f数值虽然相同，但不是同一个对象，以此为false。</p>
<p>System.out.println(c == (a+b))。</p>
<p>此时==两边有算术运算，会进行拆箱，因此此时比较的是数值，而并非对象。因此为true。</p>
<p>System.out.println(c.equals(a+b))</p>
<p>c与a+b的数值相等，为true。</p>
<p>System.out.pirnln(g == (a + b))</p>
<p>由于==两边有算术运算，所以比较的是数值，因此为true。</p>
<p>System.out.println(g.equals(a+b))。</p>
<p>Long类型的equal在比较是时候，会先判断a+b是否为Long类型，显然a+b不是，因此false</p>
<p>问题到此就结束了，以上便是自己的理解，以上如果有不对劲的地方，非常欢迎你的指点。</p>
<p><strong>完</strong>。</p>
<blockquote>
<p>关注公众号「苦逼的码农」，获取更多原创文章，后台回复「礼包」送你一份特别的大礼包</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iamshuaidi.github.io/2018/08/12/JVM(2)--一文读懂垃圾回收/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="帅地">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/JVM(2)--一文读懂垃圾回收/" itemprop="url">JVM(2)--一文读懂垃圾回收</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-12T00:00:00+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>与其他语言相比，例如c/c++，我们都知道，java虚拟机对于程序中产生的垃圾，虚拟机是会自动帮我们进行清除管理的，而像c/c++这些语言平台则需要程序员自己手动对内存进行释放。</p>
<p>虽然这种自动帮我们回收垃圾的策略少了一定的灵活性，但却让代码编写者省去了很多工作，同时也提高了很多安全性。(因为像C/C++假如你创建了大量的对象，但却由于自己的疏忽忘了将他们进行释放，可能会造成内存溢出)。</p>
<h3 id="何为垃圾？"><a href="#何为垃圾？" class="headerlink" title="何为垃圾？"></a>何为垃圾？</h3><p>刚才说了，虚拟机会自动帮助我们进行垃圾的清除，那什么样的对象我们才可以称为是垃圾对象呢？</p>
<p>假如你创建了一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man m = new Man();</span><br></pre></td></tr></table></figure>
<p>你用一个变量指向了这个对象，显然对于这个对象，你可以用变量m对这个对象进行利用，但过了一段时间，你执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = null;</span><br></pre></td></tr></table></figure>
<p>并且也并没有新的变量来指向刚才创建的对象。此时对于这个没有任何变量指向的对象，你觉得它还有用处吗？</p>
<p>显然，对于这种没有被变量指向的对象，它是一点卵用也没有的，它只能在<strong>堆</strong>随风漂流。</p>
<p>因此，对于这样的对象，我们就可以把它称为垃圾了，它早晚会被垃圾回收器给干掉。</p>
<h3 id="怎么知道它已经是垃圾对象了"><a href="#怎么知道它已经是垃圾对象了" class="headerlink" title="怎么知道它已经是垃圾对象了?"></a>怎么知道它已经是垃圾对象了?</h3><p>假如代码是你自己编写的，你可能知道这个对象啥时候应该被抛弃，你可以随时让它成为垃圾对象。</p>
<p>但是，你毕竟是你，虚拟机则没那么智能。那虚拟机是如何知道的呢？</p>
<p>上面已经说了，没有变量引用这个对象时，它就是垃圾对象了，基于这个原理，我们可以这样做啊：</p>
<p>我们可以为这个对象设置一个计数器，初始值为0，假如有一个变量指向它，那么计数器就加1，如果这个变量不在指向它了，计数器就减1。那么我们就可以判断，如果这个计数器为0的话，那它就是垃圾对象了，否则就是有用的对象。</p>
<p>对于这种方法，我们称之为<strong>引用计数法</strong>。</p>
<p>好吧，我们先来夸一夸<strong>引用计数法</strong>这种方法：</p>
<ol>
<li>实现简单。</li>
<li>效率高(一个if语句就能解决的问题想不高效都难)。</li>
</ol>
<p><strong>不好意思，接下来得说说它那个致命的缺点</strong>。</p>
<p>实际上，对于这种引用计数的方法，假如它遇到<strong>对象互相引用</strong>的话，是很难解决的。</p>
<p>先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Man m1 = new Man();</span><br><span class="line">Man m2 = new Man();</span><br><span class="line">//互相引用</span><br><span class="line">m1.instance = m2;//假设Man有instance这个属性</span><br><span class="line">m2.instance = m1;</span><br><span class="line"></span><br><span class="line">m1 = null;</span><br><span class="line">m2 = null;</span><br><span class="line">System.gc();//按道理对象应该被回收</span><br></pre></td></tr></table></figure>
<p>这段代码m1和m2都指向null了，按道理两个对象已经是无用对象，应该被回收，但是，两个对象之间彼此有一个instance的属性互相牵引的对方，导致两个对象并没有被回收。</p>
<p>这个缺点够致命吧？</p>
<p>所以，虚拟机并没有采用这种<strong>引用计数</strong>的方法。</p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>除了这种方法，我们还有其他的方法吗？</p>
<p>答案是有的，必须得有啊。这种方法就是传说中的<strong>可达性分析</strong>，(我靠，听名字是真的高级啊)。它的<strong>工作原理</strong>是这样的：</p>
<p>在程序开始时，会建立一个引用根节点(GC Roots)，并构建一个引用图。当需要判断谁是垃圾时，我们可以从这个根节点进行遍历，如果没有被遍历到的节点则是<strong>垃圾对象</strong>，否则就是有用对象。如下图:</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/12/16529ca3f6a90edd?w=710&amp;h=380&amp;f=png&amp;s=46373" alt=""></p>
<p>这个方法可以解决循环相互引用的问题，但是这个方法并没有<strong>引用计数法</strong>高效，毕竟要遍历图啊。</p>
<p><strong>总结下判断是否为垃圾对象的算法：</strong></p>
<ol>
<li>引用计数法。</li>
<li>可达性分析。</li>
</ol>
<h3 id="何时进行垃圾回收"><a href="#何时进行垃圾回收" class="headerlink" title="何时进行垃圾回收"></a>何时进行垃圾回收</h3><p>可能有人会觉得这个问题很奇怪，觉得<strong>看到垃圾就回收</strong>不是很好。对于这个我只能说：</p>
<ol>
<li>看到房间有一点垃圾你会马上扫？还是等到某个时间点或者当垃圾积累到一定的数量再扫？</li>
<li>虚拟机可没那么智能可以马上识别这个对象是垃圾对象，它还得遍历所有对象才能知道有哪些是垃圾对象。</li>
</ol>
<p>所以说，你总不能几秒(我们假设几秒是贼短的时间）就让虚拟机遍历一下所有对象吧？</p>
<blockquote>
<p>这里先说明一下，当垃圾回收器在进行垃圾回收的时候，为了保证垃圾回收不受干扰，是会暂停所有线程的，此时程序无法对外部的请求进行响应。(因为你想啊，当你在可达性分析的时候，那些引用关系还在不断着变化，那不很难受)。</p>
</blockquote>
<p>而且频繁的垃圾回收，对于有一些程序，是很影响用户体验的，例如你在玩游戏，系统动不动就停顿一下，怕你是要把这游戏给删了。</p>
<p>所以说，垃圾回收是会等到内存被使用了一定的比例的时候，才会触发垃圾回收。至于这个比例是多少，这可能就是人为规定的了。</p>
<h3 id="怎么回收？"><a href="#怎么回收？" class="headerlink" title="怎么回收？"></a>怎么回收？</h3><p>当我们标记好了哪些是垃圾，想要进行回收的时候，该怎么回收比较好呢？</p>
<p>可能有一些人就觉得奇怪，这还不简单，看见它是垃圾，直接回收不就得了。</p>
<p>其实这也不无道理，简单粗暴，直接回收。</p>
<p>是的，确实有这样的算法，看哪些是被我们标记的垃圾，看见了就直接回收。这种算法我们称之为<strong>标记–清除算法</strong>。</p>
<p><strong>标记-清除算法</strong>工作原理：就是先标记出所有需要回收的对象，然后在统一回收所有被标记过的对象。</p>
<p>不过，<strong>那些人</strong>你可别得意啊，因为这种方法虽然简单暴力，但它有个致命的缺点就是：</p>
<p>标记清除过后，会产生大量的<strong>不连续内存碎片</strong>，如果不连续的碎片过多的话，，可能会导致有一些<strong>大的对象</strong>存不进去。这样，会导致下面两个问题：</p>
<ol>
<li>有些内存浪费了。</li>
<li>对象存不进去，会又一次触发垃圾回收。</li>
</ol>
<p><strong>复制算法</strong></p>
<p>为了解决这种问题，另外一种算法出现了—<strong>复制算法</strong>。就是说，它会将可用的内存按容量划分成两块。然后每次只使用其中的一块，当这一块快用完的时候，就会触发垃圾回收，它会把还存活的对象全部复制到另外一块内存中去，然后把这块内存全部清理了。</p>
<p>这样，就不会出现碎片问题了。</p>
<p>居然帮我们解决了我们必须夸一下它：不仅帮我们解决了问题，而且实现上也简单、运行也高效。</p>
<p>但是(凡事都有个但是的)，它也是有缺点的，缺点很明显，发现了没有。假如每次存活的对象都很少很少，那另外一块内存不是几乎没有用到？所以说，这种方法有可能导致另外一半内存几乎没用了。内存那么宝贵，这可是很严重的问题。</p>
<p><strong>优化策略</strong>：可以告诉你，有研究显示，其实有98%的对象都是<strong>朝生夕死</strong>的，也就是说，每次存活的对象确实很少很少。既然我们都知道存活的对象很少很少了，那我们干嘛还1：1的比例来分配？所以说，HotShot虚拟机是默认按8:1的比例来分配的。这样，就不会出现很多内存没用到的问题了。</p>
<p>可能有人会说，万一占比为1/9的内存不够用了怎么办？不就没地方存那些活的对象？实际上，当内存不够用时，可以向其他地方借些内存来使用，例如<strong>老年代</strong>里的内存。</p>
<blockquote>
<p>这里说明一下新生代和老年代：说白了，新生代就是刚刚创建不久的对象，而老年代是已经活了挺久的对象。也就是说，有一些对象是确实活的比较久的，对于这种对象，我们另外给它分配内存来养老，而且垃圾回收时，我们不用每次都来这里查找有没垃圾对象，因为这些对象是垃圾的几率会比较小。</p>
</blockquote>
<p><strong>下面在简单介绍另外两种算法：</strong></p>
<ol>
<li>标记-整理算法：这种算法和<strong>标记-清除算法</strong>类似，不过它把垃圾清除了之后，会让存活的对象往一个方向靠拢，以此来整理碎片。</li>
<li>分代收集算法：所谓分代就是把对象分成类似上面说的老年代和新生代，在新手代一般每次垃圾回收时死的对象一般都会比较多，而老年代会比较少，基于这种关系，我们就可以采取不同的算法来针对了。</li>
</ol>
<p><strong>总结下垃圾回收的几种算法：</strong></p>
<ol>
<li>标记-清除算法。</li>
<li>复制算法。</li>
<li>标记-整理算法。</li>
<li>分代收集算法。</li>
</ol>
<h3 id="最后给大家几种垃圾回收器"><a href="#最后给大家几种垃圾回收器" class="headerlink" title="最后给大家几种垃圾回收器"></a>最后给大家几种垃圾回收器</h3><p>对于垃圾的回收，你是想一边运行程序其他代码一边进行垃圾回收？还是想把垃圾全收好再来执行程序的其他代码？虽然说最终使用cpu的时间是一样，但两种方式还是有区别的。</p>
<p>下面简单介绍几种垃圾回收器，看看他们都使用哪种方。</p>
<p><strong>(1).Serial收集器</strong></p>
<p>serial(串行),看这个英文单词就知道这是一个单线程收集器。也就是说，它在进行垃圾回收时，必须暂停其他所有线程。显然，有时垃圾回收停顿的比较久的话，这对于用户来说是很难受的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/12/16529ca9ce11d978?w=472&amp;h=223&amp;f=png&amp;s=78973" alt=""></p>
<p><strong>(2).ParNew</strong></p>
<p>这个收集器和Serial很类似，进行垃圾回收的时候，也是得暂停其他所有线程，不过，它可以多条线程工作进行垃圾回收。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/12/16529cace210a415?w=458&amp;h=245&amp;f=png&amp;s=81608" alt=""></p>
<p><strong>(3).Parallel Scavenge收集器</strong></p>
<p>parallel,并行的意思。也是可以多线程进行垃圾回收处理，但是它与ParNew不同。它会严格控制垃圾回收的时间与执行其他代码的时间之间的比例。我们来看一个名词：<strong>吞吐量</strong>。</p>
<p>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。</p>
<p>也就是说，Parallet Scavenge收集器会严格控制吞吐量，至于这个吞吐量是多少，这个可以人为设置。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/12/16529cb073097129?w=458&amp;h=245&amp;f=png&amp;s=81608" alt=""></p>
<h4 id="下面两个收集器重点介绍下"><a href="#下面两个收集器重点介绍下" class="headerlink" title="下面两个收集器重点介绍下"></a>下面两个收集器重点介绍下</h4><p><strong> (4).CMS（Concurrent Mark Sweep）收集器</strong></p>
<p>CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>其中初始标记、重新标记这两个步骤仍然需要<strong>暂停其他线程</strong>。但另外两个步骤可以和其他线程<strong>并发执行</strong>。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程 <strong>(说白了就是把整个图都遍历了，找出没有的对象)</strong>，</p>
<p>而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程几乎是与与用户线程一起并发地执行。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/12/16529cb4c17c197b?w=477&amp;h=234&amp;f=png&amp;s=90727" alt=""></p>
<p><strong>(5).G1收集器</strong></p>
<p>这个估计是最牛的收集器了。该收集器具有如下特点：</p>
<ol>
<li>并行与并发：G1能充分利用现代计算器多CPU,多核的硬件优势，可以使用并发或并行的方式来缩短让其他线程暂停的优势。</li>
<li>分代收集：就是类似像分出新生代和老年代那样处理。</li>
<li>空间整合：采用了<strong>复制算法</strong>+<strong>标记-整合算法</strong>的特点来回收垃圾。就是整体采用<strong>标记-整理算法</strong>，局部采用<strong>复制算法</strong>。</li>
<li>可预测停顿：这个就牛了，就是说，它能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。</li>
</ol>
<p>它的执行过程大体如下：</p>
<ol>
<li>初始标记。</li>
<li>并发标记。</li>
<li>最终标记。</li>
<li>筛选回收。</li>
</ol>
<p>这个流程和CMS很相似，它也是在<strong>初始标记</strong>和<strong>最终标记</strong>需要暂停其他线程，但其他两个过程就可以和其他线程并发执行。</p>
<p>刚才我们说了G1收集器哪些优点，例如<strong>可预测停顿</strong>，这也使得<strong>筛选回收</strong>，是可以预测停顿垃圾回收的时间的，也就是说，停顿的时间是用户自己可以控制的，这也使得一般情况下，在<strong>筛选回收</strong>的时候，我们会暂停其他线程的执行，把所有时间都用到<strong>筛选回收</strong>上。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/12/16529cb849b14484?w=645&amp;h=224&amp;f=png&amp;s=25815" alt=""></p>
<p>本次讲解到这里。</p>
<p><strong>完</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iamshuaidi.github.io/2018/08/10/JVM(1)---虚拟机在运行期的优化策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="帅地">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/JVM(1)---虚拟机在运行期的优化策略/" itemprop="url">JVM(1)---虚拟机在运行期的优化策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-10T00:00:00+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-解释器与JIT编译器"><a href="#1-解释器与JIT编译器" class="headerlink" title="1.解释器与JIT编译器"></a>1.解释器与JIT编译器</h3><p>首先我们先来了解一下运行在虚拟机之上的<strong>解释器</strong>与<strong>JIT编译器</strong>。</p>
<p>当我们的虚拟机在运行一个java程序的时候，它可以采用两种方式来运行这个java程序：</p>
<ol>
<li>采用解释器的形式，也就是说，在运行.class运行的时候，解释器一边把.class文件翻译成<strong>本地机器码</strong>，一边执行。显然这种一边解释翻译一边执行发方式，可以使我们立即启动和执行程序，省去编译的时间。不过由于需要一遍解释翻译，会让程序的执行速度比较慢。</li>
<li>采用JIT编译器的方式：注意，JIT编译器是把.class文件翻译成<strong>本地机器码</strong>，而javac编译器是把.java源文件编译成.class文件。如果采用JIT编译器的方式则是在启动运行一个程序的时候，先把.class文件全部翻译成<strong>本地机器码</strong>，然后再来执行，显然，这种方式在执行的时候由于不用对.clasa文件进行翻译，所以执行的速度会比较快。当然，代价就是我们需要花销一定的时间来把字节码翻译成<strong>本地机器码</strong>。这样，程序在启动的时候，会有更多的延迟。</li>
</ol>
<p>这两种方式可以说是各有优势，虚拟机(特指HotSpot虚拟机)在执行的时候，一般会采用两种方式结合的策略。</p>
<p>也就是说，在程序执行的时候，有些代码采用<strong>解释器</strong>的方式，有些代码采用<strong>编译器</strong>，称之为<strong>即时编译</strong>。一般我们会对<strong>热点代码</strong>采用编译器的方式。</p>
<h3 id="2-编译对象与触发条件"><a href="#2-编译对象与触发条件" class="headerlink" title="2.编译对象与触发条件"></a>2.编译对象与触发条件</h3><p>上面已经说了，运行过程中，如果遇到<strong>热点代码</strong>就会触发对该代码进行编译，编译成本地机器码。</p>
<p>什么是热点代码？</p>
<p><strong>热点代码</strong>主要有一下两类：</p>
<ol>
<li>被多次调用的方法。</li>
<li>被多次执行的循环体。</li>
</ol>
<p>不过这里需要注意的是，由于循环体是存在方法之中的，尽管编译动作是由循环体触发的，但编译器仍然会以这个方法来作为编译的对象。</p>
<h3 id="3-热点探测"><a href="#3-热点探测" class="headerlink" title="3.热点探测"></a>3.热点探测</h3><p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为我们称之为<strong>热点探测</strong>。热点探测判定有以下两种方式：</p>
<ol>
<li>基于采样的热点探测：这种方式虚拟机会周期性着检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那么这个方法就是<strong>热点方法</strong>。可能有人会问，所谓<strong>经常</strong>，那什么样才算经常，对于这个我只能告诉你，这个取决于你自己的设置，如果自己没有进行相应的设置的话，就采用虚拟机的默认设置。</li>
<li>基于计数器的热点探测：这种方法我们会为每个方法设置一个<strong>计数器</strong>，统计方法被调用的次数，如果到达一定的次数，我们就把它当作是<strong>热点方法</strong>。</li>
</ol>
<p><strong>两种方法的优缺点</strong>：</p>
<p>显然第一种方法在实现上是比较简单、高效的，但是缺点也很明显，精确度不高，容易受到线程阻塞等别的外界因素的干扰。</p>
<p>第二种方式的统计结果会很精确，但需要为每个方法建立并维护一个计数器。实现上会相对复杂一点并且开销也会大点。</p>
<p>不过，这里需要指出的是，我们的HotSpot虚拟机采用的是<strong>基于计数器</strong>的方式。</p>
<blockquote>
<p>说明：虚拟机在执行方法的时候，会先判断该方法是否存在已经编译好的版本，如果存在，则执行编译好的<strong>本地机器码</strong>，否则，采用一边解释一边编译的方式。</p>
</blockquote>
<h3 id="4-编译优化技术"><a href="#4-编译优化技术" class="headerlink" title="4.编译优化技术"></a>4.编译优化技术</h3><p>先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">if(false)&#123;</span><br><span class="line">    System.out.println(&quot;无用代码&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int b = 2;</span><br></pre></td></tr></table></figure>
<p>对于这段代码，我们都知道是if语句体里面的代码是一定不可能会被执行到的，也就是说，这实际上是一段一点用处也没有的代码，在执行时只能浪费判断时间。</p>
<p>实际上，对于我们书写的代码，编译器在编译的时候是会进行优化的。对于上面的代码，编译优化之后会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br></pre></td></tr></table></figure>
<p>那段无用的代码会被消除掉。</p>
<h4 id="各种编译优化策略"><a href="#各种编译优化策略" class="headerlink" title="各种编译优化策略"></a>各种编译优化策略</h4><p>我们刚才已经说了，对于有些被多次调用的方法或者循环体，虚拟机会先把他们编译成本地机器码。由于这些<strong>热点代码</strong>都是一些会被多次重复执行的代码，为了使得编译好的代码更加完美，运行的更快。编译器做了很多的编译优化策略，例如上面的无用代码消除就是其中的一种。</p>
<p>下面我们来讲讲大概都有那些优化策略：</p>
<p>大概预览一波：</p>
<ol>
<li>公共子表达式消除。</li>
<li>数组范围检查消除。</li>
<li>方法内联。</li>
<li>逃逸分析。</li>
</ol>
<p><strong>(1).公共子表达式消除</strong></p>
<p>含义：如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中的所有变量的值都没有发生变化，那个 E 的这次出现就成为了公共子表达式。对于这样的表示式，没有必要对它再次进行计算了，直接沿用之前的结果就可以了。</p>
<p>我们来举个例子。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int d = (c * b) * 10 + a + (a + b * c);</span><br></pre></td></tr></table></figure>
<p>这段代码到了即时编译器的手里，它会进行如下优化：</p>
<p>表达式中有两个 b * c的表达式，并且在计算期间b与c的值并不会变。所以这条表达式可能会被视为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int d = E * 10 + a+ (a + E);</span><br></pre></td></tr></table></figure>
<p>接着继续优化成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int d = E * 11 + a + a;</span><br></pre></td></tr></table></figure>
<p>接着<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int d = E * 11 + 2a;</span><br></pre></td></tr></table></figure></p>
<p>这样，代码在执行的时候，就会节省了一些时间了。</p>
<p><strong>(2).数组范围检查消除</strong></p>
<p>我们知道，java是一门动态安全的语言，对数组的访问不像c/c++那样，可以采用指针指向一块可能不存在的区域。例如假如有一个数组arr[]，在java语言中访问数组arr[i]的时候，是会先进行上下界范围检查的，即先检查i是否满足i &gt;= 0 &amp;&amp; i &lt; arr.length这个条件。如果不满足则会抛出相应的异常。这种安全检查策略可以避免<strong>溢出</strong>。但每次数组访问都会进行这样一次检查无疑在速度性能上造成一定的影响。</p>
<p>实际上，对于这样一种情况，编译器也是可以帮助我们做出相应的优化的。例如对于数组的下标是一个常量的，如arr[2]，只要在编译期根据数据流分析来确定arr.length的值，并判断下标‘2’并没有越界，这样在执行的时候就无需在判断了。</p>
<p>更常见的情况是数组访问发生在循环体中，并且使用循环变量来进行数组的访问，对于这样的情况，只要编译器通过数据流就可以判断循环变量的取值范围是否在[0, arr.length)之内，如果是，那么整个循环中就可以节省很多次数组边界检测判断的操劳了。</p>
<p>对于这些安全检查所消耗的时间，实际上，我们还可以采用另外一种策略–<strong>隐式异常处理</strong>。例如当我们在访问一个对象arr的属性arr.value的时候，没有优化之前虚拟机是这样处理的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(arr != null)&#123;</span><br><span class="line">    return arr.value;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    throw new NollPointException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用优化策略之后编程这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    return arr.value;</span><br><span class="line">&#125;catch(segment_fault)&#123;</span><br><span class="line">    uncommon_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是说，虚拟机会注册一个Segment Fault信号的异常处理器(uncommon_trap())，这样当arr不为空的时候，对value的访问可以省去对arr的判断。代价就是当arr为空时，必须转入到异常处理器中恢复并抛出NullPointException异常，这个过程会从用户态转到内核态中处理，结束后在回到用户态，速度远比一次判断空检查慢。当arr极少为null的时候，这样做是值得的，但假如arr经常为null时，那么会得不偿失。</p>
<p>不过，虚拟机还是挺聪明的，它会根据运行期收集到的信息来自动选择最优方案。</p>
<p><strong>(3).方法内联</strong></p>
<p>先看一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void f(Object obj)&#123;</span><br><span class="line">    if)(obj != null)&#123;</span><br><span class="line">        System.out.println(&quot;do something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void test(String[] args)&#123;</span><br><span class="line">    Object obj = null;</span><br><span class="line">    f(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这段代码，如果把两个方法结合在一起看，我们可以发现test()方法里面都是一些无用的代码。因为f(obj)这个方法的调用，没啥卵用。但是如果不做内联优化，后续尽管进行了无用代码的消除，也是无法发现任何无用代码的，因为如果把f(Object obj)和test(String[] args)两个发放分开看的话，我们就无法得只f(obj)是否有用了。</p>
<p>内联优化后的代码可以是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void f(Object obj)&#123;</span><br><span class="line">    if)(obj != null)&#123;</span><br><span class="line">        System.out.println(&quot;do something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void test(String[] args)&#123;</span><br><span class="line">    Object obj = null;</span><br><span class="line">    //该方法直接不执行了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(4).逃逸分析</strong></p>
<p>逃逸分析是目前Java虚拟机比较前沿的优化技术，它并非是直接优化代码，而是为其他优化手段提供依据发分析技术。</p>
<p>逃逸分析主要是对<strong>对象动态作用域</strong>进行分析：当一个对象在某个方法被定义后，它有可能被外部的其他方法所引用，例如作为参数传递给其他方法，称之为<strong>方法逃逸</strong>，也有可能被外部线程访问到，例如类变量，称之为<strong>线程逃逸</strong>。</p>
<p>假如我们可以证明一个对象并不会发生逃逸的话，我们就可以通过一些方式对这个变量进行一些高效的优化了。如下所示：</p>
<p><strong>1).栈上分配</strong></p>
<p>我们都知道一个对象创建之后是放在<strong>堆</strong>上的，这个对象可以被其他线程所共享，并且我们知道在堆上的对象如果不再使用时，虚拟机的垃圾收集系统就会对它进行帅选并回收。但无论是<strong>回收</strong>还是<strong>帅选</strong>，都是需要花费时间的。</p>
<p>但是假如我们知道这个对象不会逃逸的话，我们就可以直接在栈上对这个对象进行内存分配了，这样，这个对象所占用的内存空间就可以随进栈和出栈而自动被销毁了。这样，垃圾收集系统就可以省了很多帅选、销毁的时间了。</p>
<p><strong>2).同步消除</strong></p>
<p>线程同步本身是一个相对耗时的过程，如果我们能判断这个变量不会逃出线程的话，那么我们就可以对这个变量的同步措施进行消除了。</p>
<p><strong>3).标量替换</strong></p>
<p>什么是标量？</p>
<p>当一个数据无法分解成更小的时候，我们称之为<strong>变量</strong>，例如像int,long,char等基本数据类型。相对地，如果一个变量可以分解成更小的，我们称之为<strong>聚合量</strong>，例如Java中的对象。</p>
<p>假如这个对象不会发生逃逸。</p>
<p>我们可以根据程序访问的情况，如果一个方法只是用到一个对象里面的若干个属性，我们在真正执行这个方法的时候，我们可以不创建这个对象，而是直接创建它那几个被使用到的变量来代替。这样，不仅可以节省内存以及时间，而且这些变量可以随出栈入栈而销毁。</p>
<p>不过，对于编译器优化的技术还有很多，上面这几种算是比较典型的。</p>
<p>本次讲解到这里。</p>
<p><strong>完</strong></p>
<p>参考书籍：深入Java虚拟机</p>
<blockquote>
<p>如果你习惯在微信公众号看技术文章<br>想要获取更多资源的同学<br>欢迎关注我的公众号：<strong>苦逼的码农</strong><br>每周不定时更新文章，同时更新自己算法刷题记录。</p>
</blockquote>
<p>煎熬了几分</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iamshuaidi.github.io/2018/08/08/从jvm角度看懂类初始化、方法重载、重写。/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="帅地">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/08/从jvm角度看懂类初始化、方法重载、重写。/" itemprop="url">从jvm角度看懂类初始化、方法重载、重写。</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-08T00:00:00+08:00">
                2018-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h1><p>在讲类的初始化之前，我们先来大概了解一下类的声明周期。如下图</p>
<p>类的声明周期可以分为7个阶段，但今天我们只讲<strong>初始化</strong>阶段。我们我觉得出来<strong>使用</strong>和<strong>卸载</strong>阶段外，<strong>初始化</strong>阶段是最贴近我们平时学的，也是笔试做题过程中最容易遇到的，假如你想了解每一个阶段的话，可以看看<strong>深入理解Java虚拟机</strong>这本书。</p>
<p>下面开始讲解初始化过程。</p>
<p>大家先想一个问题，当我们在运行一个java程序时，每个类都会被初始化吗？假如并非每个类都会执行初始化过程，那什么时候一个类会执行初始化过程呢？</p>
<p>答案是并非每个类都会执行初始化过程，你想啊，如果这个类根本就不用用到，那初始化它干嘛，占用空间。</p>
<p>至于何时执行初始化过程，虚拟机规范则是严格规定了<strong>有且只有</strong>5中情况会马上对类进行<strong>初始化</strong>。</p>
<ol>
<li>当使用<strong>new</strong>这个关键字实例化对象、读取或者设置一个类的<strong>静态字段</strong>，以及调用一个类的静态方法时会触发类的初始化(注意，被final修饰的静态字段除外)。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时，如果这个类还没有进行过初始化，则会触发该类的初始化。</li>
<li>当初始化一个类时，如果其父类还没有进行过初始化，则会先触发其父类。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个…..(省略，说了也看不懂，哈哈)。</li>
</ol>
<p>注意是<strong>有且只有</strong>。这5种行为我们称为对一个类的<strong>主动引用</strong>。</p>
<h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><p>类的初始化过程都干了些什么呢？</p>
<p>在类的初始化过程中，说白了就是执行了一个<strong>类构造器<clinit>()方法</clinit></strong>过程。</p>
<p>至于clinit()方法都包含了哪些内容？</p>
<p>实际上，clinit()方法是由编辑器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态语句块(static{}块)中的语句合并产生的，编辑器收集的顺序则是由语句在源文件中出现的顺序来决定的。并且<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问</strong>。如下面的程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        t = <span class="number">10</span>;<span class="comment">//编译可以正常通过</span></span><br><span class="line">        System.out.println(t);<span class="comment">//提示illegal forward reference错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给大家抛个练习</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    public static int t1 = 10;</span><br><span class="line">    static &#123;</span><br><span class="line">        t1 = 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    public static int t2 = t1;</span><br><span class="line">&#125;</span><br><span class="line">//测试调用</span><br><span class="line">class Test2&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(Son.t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是什么呢？</p>
<p>答案是20。我相信大家都知道为啥。因为会先初始化父类啊。</p>
<p>不过这里需要注意的是，对于类来说，执行该类的clinit()方法时，会先执行父类的clinit()方法，但对于接口来说，执行接口的clinit()方法并不会执行父接口的clinit()方法。只有当用到父类接口中定义的变量时，才会执行父接口的clinit()方法。</p>
<h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><p>上面说了类初始化的五种情况，且称之为主动引用。居然存在主动，也意味着存在所谓的<strong>被动</strong>引用。这里需要提出的是，被动引用并不会触发类的初始化。下面，我们举例几个被动引用的例子：</p>
<ol>
<li>通过子类引用父类的静态字段，不会触发子类的初始化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1.通过子类引用父类的静态字段，不会触发子类的初始化</span><br><span class="line"> */</span><br><span class="line">public class FatherClass &#123;</span><br><span class="line">    //静态块</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;FatherClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int value = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SonClass extends FatherClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SonClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> class Test3&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(SonClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FatherClass init</span><br></pre></td></tr></table></figure></p>
<p>说明并没有触发子类的初始化</p>
<ol start="2">
<li>通过数组定义来引用类，不会触发此类的初始化。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Test3&#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">       SonClass[] sonClass = new SonClass[10];//引用上面的SonClass类。</span><br><span class="line">   &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 输出结果是啥也没输出。</p>
<ol start="3">
<li>引用其他类的<strong>常量</strong>并不会触发那个类的初始化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class FatherClass &#123;</span><br><span class="line">    //静态块</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;FatherClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final String value = &quot;hello&quot;;//常量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test3&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(FatherClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:hello</p>
<p>实际上，之所以没有输出”FatherClass init”,是因为在编译阶段就已经对这个常量进行了一些优化处理，例如，由于Test3这个类用到了这个常量”hello”，在编译阶段就已经将”hello”这个常量储存到了Test3类的常量池中了，以后对FatherClass.value的引用实际上都被转化为Test3类对自身常量池的引用了。也就是说，在编译成class文件之后，两个class已经没啥毛关系了。</p>
<hr>
<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>对于重载，我想学过java的都懂，但是今天我们中虚拟机的角度来看看重载是怎么回视。</p>
<p>首先我们先来看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//定义几个类</span><br><span class="line">public abstract class Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">&#125;</span><br><span class="line">class Lion extends Animal&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test4&#123;</span><br><span class="line">    public void run(Animal animal)&#123;</span><br><span class="line">        System.out.println(&quot;动物跑啊跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void run(Dog dog)&#123;</span><br><span class="line">        System.out.println(&quot;小狗跑啊跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void run(Lion lion)&#123;</span><br><span class="line">        System.out.println(&quot;狮子跑啊跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //测试</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal dog = new Dog();</span><br><span class="line">        Animal lion = new Lion();;</span><br><span class="line">        Test4 test4 = new Test4();</span><br><span class="line">        test4.run(dog);</span><br><span class="line">        test4.run(lion);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p>动物跑啊跑</p>
<p>动物跑啊跑</p>
<p>相信大家学过重载的都能猜到是这个结果。但是，为什么会选择这个方法进行重载呢？虚拟机是如何选择的呢？</p>
<p>在此之前我们先来了解两个概念。</p>
<p>先来看一行代码：</p>
<p>Animal dog = new Dog();</p>
<p>对于这一行代码，我们把Animal成为变量dong<strong>的静态类型</strong>，而后面的Dog称为变量dog的<strong>实际类型</strong>。</p>
<p>所谓静态类型也就是说，在代码的编译期就可以判断出来了，也就是说在编译期就可以判断dog的静态类型是啥了。但在编译器无法知道变量dog的<strong>实际类型</strong>是什么。</p>
<p>现在我们再来看看虚拟机是根据什么来<strong>重载</strong>选择哪个方法的。</p>
<p>对于静态类型相同，但实际类型不同的变量，虚拟机在重载的时候是根据参数的静态类型而不是实际类型作为判断选择的。并且静态类型在编译器就是已知的了，这也代表在编译阶段，就已经决定好了选择哪一个重载方法。</p>
<p>由于dog和lion的静态类型都是Animal,所以选择了run(Animal animal)这个方法。</p>
<p>不过需要注意的是，有时候是可以有多个重载版本的，也就是说，重载版本并非是唯一的。我们不妨来看下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void sayHello(Object arg)&#123;</span><br><span class="line">        System.out.println(&quot;hello Object&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(int arg)&#123;</span><br><span class="line">        System.out.println(&quot;hello int&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(long arg)&#123;</span><br><span class="line">        System.out.println(&quot;hello long&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Character arg)&#123;</span><br><span class="line">        System.out.println(&quot;hello Character&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(char arg)&#123;</span><br><span class="line">        System.out.println(&quot;hello char&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(char... arg)&#123;</span><br><span class="line">        System.out.println(&quot;hello char...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Serializable arg)&#123;</span><br><span class="line">        System.out.println(&quot;hello Serializable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //测试</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        sayHello(&apos;a&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iamshuaidi.github.io/2018/07/27/互联网协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="帅地">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/27/互联网协议/" itemprop="url">互联网协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T00:00:00+08:00">
                2018-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一文读懂一台计算机是如何把数据传送给另外一台计算机的"><a href="#一文读懂一台计算机是如何把数据传送给另外一台计算机的" class="headerlink" title="一文读懂一台计算机是如何把数据传送给另外一台计算机的"></a>一文读懂一台计算机是如何把数据传送给另外一台计算机的</h1><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>好久没更新文章了，说真，写文章不难，但坚持原创写文章真的很难。主要是前阵子有其他事，一直没时间写。现在，又打了鸡血来坚持更新文章了，在此感谢那些一直关注着的读者。从今天起，我会每周坚持更新若干篇原创文章，当然，我说的“原创”文章并非所有东西都是原创的，是指参考了大量了资料之后，用自己的话描述总结出来，当然，会有一些总结性的话很类似，因此我觉得作者说的很清晰，才采用了这句话。虽然很花时间，但只要让你有所收获，那便是我坚持写下去动力。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>上面说了一些题外话，哈哈。下面我们开始今天的知识点。</p>
<p>互联网相隔n公里路的两台计算机，是如何进行数据的传送的呢？在成千上万台的计算机中，一台计算机是如何正确着找到另外一个计算机，并把数据传给它的呢？   </p>
<p>学过计算机网络的同学可能知道，在这互联网中，计算机与计算机之间的数据传送，主要是基于各种“协议”串联起来的。不过今天要讲的，并不会详细去讲各种协议，而是通过各种简化之后，让你大概知道数据之间传送的原理。</p>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>互联网中数据的传送，其实分为好几层来处理数据的，每一层有它自己明确的功能。例如就像流水线生产一样，一部分人负责这部分的工作，处理完之后就把剩余的工作扔给另外一部分人来处理……</p>
<p>对于互联网数据传送的分层模型，有分成七层的，有分成5层的，还有分成4层的。例如分成七层模型的如下(从上到下)：</p>
<ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p>七层中，越往下越靠近计算机底层，越往上越靠近用户。  </p>
<p>不过，我们今天要讲的，是以分成五层的模型来讲。其分层如下图：</p>
<p><img src="https://i.imgur.com/GOD8J29.png" alt=""></p>
<p>相当于把应用层、表示层、会话层看成是一层的。接下来我们从下往上来一步一步讲，看看如何从一台计算机准确着传给另一台计算机的。 </p>
<h1 id="一-物理层"><a href="#一-物理层" class="headerlink" title="一. 物理层"></a>一. 物理层</h1><p>一台计算机与另一台计算机要进行通信，第一件要做的事是什么？当然是要把这台计算机与另外的其他计算机连起来啊，例如可以通过光纤啊，电缆啊，双绞线啊等物体把他们联起来。然后才能进行通信，也就是说，，物理层负责把两台计算机连起来，然后在计算机之间传送0,1这样的电信号。</p>
<h1 id="二-数据链路层"><a href="#二-数据链路层" class="headerlink" title="二. 数据链路层"></a>二. 数据链路层</h1><p>前面说了，物理层它只是单纯着负责在计算机之间传输0，1这样的电信号。假如这些0，1组合的传送毫无规则，计算机是解读不了的。因此，我们需要制定一套规则来进行0，1的传送。例如多少个电信号为一组啊，每一组信号应该如何标识才能让计算机读懂啊等。    </p>
<p><strong>数据链路层</strong>工作在物理层之上，负责给这些0，1制定传送的规则，然后另一方再按照相应的规则来进行解读。</p>
<h4 id="1-以太网协议"><a href="#1-以太网协议" class="headerlink" title="1. 以太网协议"></a>1. 以太网协议</h4><p>以太网协议规定，一组电信号构成一个数据包，把这个数据包称之为“桢”。每一个桢由<strong>标头(Head)</strong>和<strong>数据(Data)</strong>两部分组成。如下：</p>
<p><img src="https://i.imgur.com/RIvRgcy.png" alt=""></p>
<p>这个桢的最大长度是1518个字节，最小长度为64字节。假如需要传送的数据很大的话，就分成多个桢来进行传送。</p>
<p>对于<strong>表头</strong>和<strong>数据</strong>这两个部分，他们存放的都是一些什么数据呢？我猜你眯着眼睛都能想到他们应该放什么数据。    毫无疑问，我们至少得知道这个桢是谁发送，发送给谁的等这些信息吧？所以<strong>标头</strong>部分主要是一些说明数据，例如发送者，接收者等信息。而<strong>数据</strong>部分则是这个数据包具体的，想给接受的内容。</p>
<p>大家想一个问题，一个桢的长度是64~1518个字节，也就是说桢的长度不是固定的，那你觉得<strong>标头</strong>部分的字节长度是固定的吗？它当然是固定的啊，假如不是固定的，每个桢都是单独发的，那计算机怎么知道<strong>标头</strong>是几个字节，<strong>数据</strong>是几个字节。所以标头部分的字节是固定的，并且固定为18个字节。</p>
<h4 id="2-MAC地址"><a href="#2-MAC地址" class="headerlink" title="2. MAC地址"></a>2. MAC地址</h4><p>把一台计算的的数据通过物理层和链路层发送给另一台计算机，究竟是谁发给谁的，计算机与计算机之间如何区分，，你总得给他们一个唯一的<strong>标识</strong>吧？</p>
<p>这就是MAC地址，连入网络的每一个计算机都会有<strong>网卡</strong>接口，每一个网卡都会一个地址，这个地址就叫做<strong>MAC地址</strong>。计算机之间的数据传送，就是通过MAC地址来唯一寻找、传送的。MAC地址在网卡生产是就被唯一标识了。</p>
<h4 id="3-广播与ARP协议"><a href="#3-广播与ARP协议" class="headerlink" title="3. 广播与ARP协议"></a>3. 广播与ARP协议</h4><p><img src="https://i.imgur.com/npyjWgp.png" alt=""></p>
<p>如图，假如计算机A知道了计算机B的MAC地址，然后计算机A想要给计算机B传送数据，虽然计算机A知道了计算机B的MAC地址，可是它要怎么给它传送数据呢？计算机A不仅连着计算机B，而且计算机A也还连着其他的计算机。    虽然计算机A知道计算机B的MAC地址，可是计算机A是无法知道计算机B是分布在<strong>哪边路线</strong>上的。实际上，计算机A是通过<strong>广播</strong>的方式把数据发送给计算机B。在<strong>同一个子网中</strong>，计算机A要向计算机B发送一个数据包，这个数据包包含接收者的MAC地址。这个时候同一个子网中的计算机C,D也会收到这个数据包的，然后收到这个数据包的计算机，会把数据包的MAC地址取出来，与自身的MAC地址对比，如果两者相同，则接受这个数据包，否则就丢弃这个数据包。这种发送方式我们称之为<strong>广播</strong>,就像我们平时在广场上通过广播的形式呼叫某个人一样。  </p>
<p>那么问题来了，计算机A是如何知道计算机B的MAC地址的呢？这个时候就得由<strong>ARP协议</strong>这个家伙来解决了，不过ARP协议会涉及到IP地址，不过我们下面才会扯到<strong>IP地址</strong>。因此我们先放着，就当作是有这么一个<strong>ARP协议</strong>，通过它我们可以知道子网中其他计算机的MAC地址。</p>
<h1 id="三-网络层"><a href="#三-网络层" class="headerlink" title="三. 网络层"></a>三. 网络层</h1><p>上面我们有说到<strong>子网</strong>这个关键词，实际上我们所处的网络，是由无数个子网络构成的。广播的时候，也只有同一个子网里面的计算机能够收到。 假如没有子网这种划分的话，计算机A发一个数据包给计算机B,其他所有计算机也都能收到这个数据包，然后进行对比再舍弃。世界上有那么多它计算机，每一台计算机都能收到其他所有计算机的数据包，那就不得了了。那还不得奔溃。     因此产生了子网这么一个东西。</p>
<p>那么问题来了，我们如何区分哪些MAC地址是属于同一个子网的呢？假如是同一个子网，那我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给<strong>网关</strong>，让网关进行转发。</p>
<p>为了解决这个问题我们引入了一套新的地址协议，这个地址协议能够帮助我们区分MAC地址是否处于同一个子网中。这也是<strong>网络层</strong>负责解决的问题。</p>
<h4 id="1-IP协议"><a href="#1-IP协议" class="headerlink" title="1. IP协议"></a>1. IP协议</h4><p>这个协议就是IP协议，它所定义的地址，我们称之为IP地址。IP协议有两种版本，一种是IPv4,另一种是IPv6。不过我们目前大多数用的还是IPv4，我们现在也只讨论IPv4这个版本的协议。</p>
<p>这个IP地址由32为的二进制数组成，我们一般把它分成4段的十进制表示，地址范围为0.0.0.0~255.255.255.255</p>
<p>每一台想要联网的计算机都会有一个IP地址。这个IP地址被分为两部分，前面一部分代表<strong>网络部分</strong>，后面一部分代表<strong>主机部分</strong>。并且网络部分和主机部分的二进制位数是不固定的。</p>
<p>假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是<strong>处于同一个子网</strong>中。例如192.168.43.1和192.168.43.2,假如这两个IP地址的网络部分为24为，主机部分为8位。那么他们的网络部分都为192.168.43，所以他们处于同一个子网中。</p>
<p>可是问题来了，你怎么知道网络部分是占几位。也就是说，单单从两台计算机的IP地址，我们是无法判断他们的是否处于同一个子网中的。</p>
<p>这就引申出了另一个关键词————<strong>子码掩码</strong>。子码掩码和IP地址一样也是32位二进制数，不过它的网络部分规定全部为1，主机部分规定全部为0.也就是说，假如上面那两个IP地址的网络部分为24为，主机部分为8为的话，那他们的子码掩码都为11111111.11111111.11111111.00000000，即255.255.255.0。</p>
<p>那有了子字码掩码，如何来判端IP地址是否处于同一个子网中呢。显然，知道了子码掩码，相当于我们知道了网络部分是几位，主机部分是几位。我们只需要把IP地址与它的子码掩码做<strong>与(and)</strong>运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表是同一个子网，否则不是同一个子网。</p>
<p>例如，192.168.43.1和192.168.43.2的子码掩码都为255.255.255.0，把IP与子码掩码相与，可以得到他们都为192.168.43.0，进而他们处于同一个子网中。</p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>有了上面IP协议的知识，我们回来讲一下ARP协议。<br>有了两台计算机的IP地址，我们就可以判断出它们是否处于同一个子网之中。  假如他们处于同一个子网之中，计算机A要给计算机B发送数据时。我们可以通过ARP协议来得到计算机B的MAC地址。ARP协议也是通过广播的形式给同一个子网中的每台电脑发送一个数据包(当然，这个数据包会包含接收方的IP地址)。对方收到这个数据包之后，会取出IP地址与自身的对比，如果相同，则把自己的MAC地址回复给对方，否则就丢弃这个数据包。这样，计算机A就能知道计算机B的MAC地址了。</p>
<p>可能有人会问，知道了MAC地址之后，发送数据是通过广播的形式发送，询问对方的MAC地址也是通过广播的形式来发送，那其他计算机怎么知道你是要传送数据还是要询问MAC地址呢？其实在询问MAC地址的数据包中，在对方的MAC地址这一栏中，填的是一个特殊的MAC地址，其他计算机看到这个特殊的MAC地址之后，就能知道广播想干嘛了。</p>
<p>假如两台计算机的IP不是处于同一个子网之中，这个时候，我们就会把数据包发送给<strong>网关</strong>，然后让网关让我们进行转发传送 </p>
<h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><p>这里再说一个问题，我们是如何知道对方计算机的IP地址的呢？这个问题可能有人会觉得很白痴，心想，当然是计算机的操作者来进行输入了。这没错，当我们想要访问某个网站的时候，我们可以输入IP来进行访问，但是我相信绝大多数人是输入一个<strong>网址域名</strong>的，例如访问百度是输入<a href="http://www.baidu.com这个域名。其实当我们输入这个域名时，会有一个叫做**DNS服务器**的家伙来帮我们解析这个域名，然后返回这个域名对应的IP给我们的。" target="_blank" rel="noopener">www.baidu.com这个域名。其实当我们输入这个域名时，会有一个叫做**DNS服务器**的家伙来帮我们解析这个域名，然后返回这个域名对应的IP给我们的。</a></p>
<h1 id="四-传输层"><a href="#四-传输层" class="headerlink" title="四. 传输层"></a>四. 传输层</h1><p>虽然我们已经把数据成功从计算机A传送到计算机B了，可是，计算机B里面有各种各样的应用程序，计算机该如何知道这些数据是给谁的呢？</p>
<p>这个时候，<strong>端口(Port)</strong>这个家伙就上场了，也就是说，我们在从计算机A传数据给计算表B的时候，还得指定一个端口，以供特定的应用程序来接受处理。<br>也就是说，传输层的功能就是建立<strong>端口到端口</strong>的通信。相比网络层的功能是建立<strong>主机到主机</strong>的通信。</p>
<p>也就是说，有了IP和端口，我们就可以进行通信了。这个时候可能有人会说，我输入IP地址的时候并没有指定一个端口啊。其实呢，对于有些传输协议，已经有设定了一些默认端口了。例如http的传输默认端口是80，这些端口信息也会包含在数据包里的。</p>
<p><strong>应用层</strong></p>
<p>终于说到应用层了，应用层这一层最接近我们用户了。</p>
<p>虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有html格式的，有mp4格式的，各种各样。你确定你能看的懂？</p>
<p>因此我们需要指定这些数据的格式规则，收到后才好解读渲染。而<strong>应用层</strong>的功能，就是用来规定应用程序的数据格式的。</p>
<p>五层模型至此讲到这里。对于有些层讲的比较简洁，就随便概况了一下。如果你想详细去了解，可以去买计算机网络相应的资料。希望我的讲解能让你对计算机之间数据的传输有个大概的了解。</p>
<blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">帅地</p>
              <p class="site-description motion-element" itemprop="description">关注公众号「苦逼的码农」，获取更多原创文章，后台回复「礼包」送你一份特别的大礼包</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">帅地</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
