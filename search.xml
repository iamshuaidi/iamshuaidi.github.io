<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于我：一名来自双非学校的小混混]]></title>
    <url>%2F2018%2F08%2F19%2F%E5%85%B3%E4%BA%8E%E6%88%91%EF%BC%9A%E4%B8%80%E5%90%8D%E5%8F%8C%E9%9D%9E%E7%9A%84%E5%B0%8F%E6%B7%B7%E6%B7%B7%2F</url>
    <content type="text"><![CDATA[前言玩公众号有一两个月了，还没介绍过自己，这篇文章简单介绍下自己。 关于我本人姓林，名秋地，自称帅地，就读于广州某双非大学，专业是软件工程，现在是准大三，热爱编程。不过大一读的专业是与编程无关的，之后转专业到软件工程来，从此陷入码农的世界无法自拔。 刚到软件工程那会，感觉打acm特别有意思，心里对acm比赛充满了兴趣。于是买了各种算法的书籍，也去各大网站刷题。后来刷着刷着，说真的，那些题对于我来说，是真的难啊。一道题做了几个小时，有些题看答案也看了几个小时，没研究几道题一天就过去了。 慢慢着，发现自己并不适合打acm，加上自己参加那些牛客网什么的月赛和周周练之类的，每次都做的不大理想，于是就果断放弃打acm了，跑去好好学习其他技术。 写作历程之所以会选择写作，主要是基于以下原因： 用在刷题的时间少了，自然也就多了一些时间。个人也比较喜欢上各种博客论坛逛，在论坛里经常是只看不输出，慢慢着，萌生了去尝试写文章的想法。 从小就害怕写作文，看到一个自己心里挺懂的问题，但想要用语言把自己的想法有条理着描述出来，每次都把文字组织的很混乱。于是，也有点想去写文章锻炼一下自己的写作能力。 每次看技术书籍都看到很快，总觉得自己理解了，但每次要用的时候，发现忘了一干二净，然后经常听大佬们说，输出很重要 ….. 基于以上等原因，我开始了我的第一次写作。 最开始我是在CDNS写的文章。说真的，对于新手来说，写文章真的是太花时间了，一篇简单的文章，都能让我写四五个小时，而且写了之后也没啥人看。心想，要是我拿这四五个小时去看书，不知道还得看多少页的书呢。 大概写了几篇吧，就没去写了。写原创文章真的好累。 然后又过了几个月，心里又萌生了坚持把文章写下去的想法，加上在张哥(stormzhang)(不要告诉我你不知道帅张）的公众号里也一直强调未来写作的重要性，于是自己就真的想逼自己一把，坚持写下去。于是这次就搞了个公众号来写文章记录自己的学习历程。 说真的，自从关注了张哥的公众号之后，收获了不少思想层面上的东西，再次真的非常谢谢张哥。（张哥的公众号：stormzhang) 希望自己能够一直坚持下去….. 写作内容我的专业是软件工程，并且我现在主要用的语言是Java，所以分享的内容包括： 计算机网络。 数据库。 操作系统。 java相关的技术体系。 数据结构与算法。 Linux。 主要是自己一边学习，把所学的，感觉比较不错的，会用自己的理解写出来。 自己发现leetcode这个网站的题挺不错，而且感觉相比其他网站的题会容易一点，大佬们也经常建议把里面的题都过一遍。所以写作的内容也会分享在leetcode的刷题贴。 最后现在是准大三，毕业后的目标是bat等公司，虽然有点难。但，并非没机会。欢迎你的关注，与我一起成长。 完]]></content>
      <categories>
        <category>me</category>
      </categories>
      <tags>
        <tag>about</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊让我蒙蔽一晚上的各种常量池]]></title>
    <url>%2F2018%2F08%2F15%2F%E8%81%8A%E4%B8%80%E8%81%8A%E8%AE%A9%E6%88%91%E8%92%99%E8%94%BD%E4%B8%80%E6%99%9A%E4%B8%8A%E7%9A%84%E5%90%84%E7%A7%8D%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[在写之前我们先来看几个问题，假如你对这些问题已经很懂了的话，那大可不用看这篇文章，如果不大懂的话，那么可以看看我的想法。 问题1： 1234567891011public static void main(String[] args)&#123; String t1 = new String(&quot;2&quot;); t1.intern(); String t2 = &quot;2&quot;; System.out.println(t1 == t2); String t3 = new String(&quot;2&quot;) + new String(&quot;2&quot;); t3.intern(); String t4 = &quot;22&quot;; System.out.println(t3 == t4);&#125; 答案输出： JDK1.6是 false false JDK1.7是 false true; 问题2(把问题1的语句调换一下位置) 1234567891011public static void main(String[] args)&#123; String t1 = new String(&quot;2&quot;); String t2 = &quot;2&quot;; t1.intern(); System.out.println(t1 == t2); String t3 = new String(&quot;2&quot;) + new String(&quot;2&quot;); String t4 = &quot;22&quot;; t3.intern(); System.out.println(t3 == t4);&#125; 答案输出：false false 对于这两个问题，看了几个人的博客，可谓百花齐放，越看越懵逼 问题3 12345678910111213141516public static void main(String[] args)&#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; System.out.println(c == d); System.out.Println(e == f); System.out.println(c == (a + b)); System.out.println(c.equals(a+b)); System.out.println(g == (a + b)); System.out.println(g.equals(a + b));&#125; 答案输出： true false true true true false 问题4： 1运行时常量池与字符串常量池是什么关系？包含？ 在解决问题之前，我们先来简单了解一些常量池的一些知识点(大部分来源于周志明的深入Java虚拟机这本书)。 JVM中的几种常量池1.class文件常量池在Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用。 这里简单解释下字面量和符号引用 字面量 字面量类似与我们平常说的常量，主要包括： 文本字符串：就是我们在代码中能够看到的字符串，例如String a = “aa”。其中”aa”就是字面量。 被final修饰的变量。 符号引用 主要包括以下常量： 类和接口和全限定名：例如对于String这个类，它的全限定名就是java/lang/String。 字段的名称和描述符：所谓字段就是类或者接口中声明的变量，包括类级别变量（static)和实例级的变量。 方法的名称和描述符。所谓描述符就相当于方法的参数类型+返回值类型。 2.运行时常量池我们上面说的class文件中的常量池，它会在类加载后进入方法区中的运行时常量池。并且需要的注意的是，运行时常量池是全局共享的，多个类共用一个运行时常量池。并且class文件中常量池多个相同的字符串在运行时常量池只会存在一份。 注意运行时常量池存在于方法区中。 3.字符串常量池看名字我们就可以知道字符串常量池会用来存放字符串，也就是说常量池中的文本字符串会在类加载时进入字符串常量池。 那字符串常量池和运行时常量池是什么关系呢？上面我们说常量池中的字面量会在类加载后进入运行时常量池，其中字面量中有包括文本字符串，显然从这段文字我们可以知道字符串常量池存在于运行时常量池中。也就存在于方法区中。 不过在周志明那本深入java虚拟机中有说到，到了JDK1.7时，字符串常量池就被移出了方法区，转移到了堆里了。 那么我们可以推断，到了JDK1.7以及之后的版本中，运行时常量池并没有包含字符串常量池，运行时常量池存在于方法区中，而字符串常量池存在于堆中。 说了这么多，现在我们开始来解决上面提出了问题。 解决问题问题1： 1234567891011public static void main(String[] args)&#123; String t1 = new String(&quot;1&quot;); t1.intern(); String t2 = &quot;1&quot;; System.out.println(t1 == t2); String t3 = new String(&quot;2&quot;) + new String(&quot;2&quot;); t3.intern(); String t4 = &quot;22&quot;; System.out.println(t3 == t4);&#125; 答案输出： JDK1.6是 false false。 JDK1.7是 false true; 在解决这个问题之前，我们先来看另外一道面试中经常会问到的问题。 12String t = new String(&quot;tt&quot;); 假如程序中只有这样一行代码，那么这行代码创建了几个对象？ 我们上面说过，”tt”属于字面量，那么它会在类加载之后存在于字符串常量池中，也就是说，在 String t = new String(“tt”)这句代码执行之前，字符串常量池就已经创建了”tt”这个字符串对象了，我们都知道，new这个关键字会在堆中创建一个对象。 所以，这段代码创建了两个对象。一个在堆中，一个在字符串常量池中。 那么下面这段代码又是创建了几个对象呢？ 12String t1 = new String(&quot;tt&quot;);String t2 = new String(&quot;tt&quot;); 答是这段代码创建了三个对象，我们上面说了，字符串常量池只会保存一份内容相同的字符串。也就是说，在这两句代码执行之前，字符串常量池就已经创建了内容为”tt”的对象了。这两句代码执行之后，又在堆中创建了两个，所以一共创建了三个。 那么下面这段代码又是创建了几个对象？ 1String t = &quot;tt&quot;; 答是1个，在这段代码执行之前，字符串常量池已经创建了一个”tt”的对象，但由于这行代码并非用new的方法，所以虚拟机会在字符串常量池中寻找是否有内容为”tt”的字符串对象，如果有，则直接返回这个字符串的引用，所以最终结果只创建了一个对象。 回到我们的问题，在这里我们先解释下String 的intern方法。 例如我们调用了t.intern()。 在JDK1.6的时候，调用了这个方法之后，虚拟机会在字符串常量池在查找是否有内容与”tt”相等的对象，如果有，则返回这个对象，如果没有，则会在字符串常量池中添加这个对象。注意，是把这个对象添加到字符串常量池。 到了JDK1.7之后，如果调用了intern这个方法，虚拟机会在字符串常量池在查找是否有内容与”tt”相等的对象，如果有，则返回这个对象，如果没有。则会在堆中把这个对象的引用复制添加到字符串常量池中。注意，这个时候添加的是对象在堆中的引用。 现在开始来分析问题中的代码 t1 = new String(“1”)。 这句代码执行之前，字符串常量池中已经有”t”这个对象，执行之后会在堆中也创建一个”t”的对象，此时t1指向的是堆中的对象。 t1.intern(); 这句代码执行之后，会在字符串常量池寻早内容为”t”的对象，字符串常量池已经存在这个对象了，把这个对象返回(不过返回之后并没有变量来接收)。 t2 = “1”。 这句执行后会在字符串常量池查找内容为”t”的对象，字符串常量池已经有这个对象了，返回给t2，此时t2指向的是常量池中的对象。 一个是常量池中的对象，一个是在堆中的对象，两者能相等吗？因此 t1 与 t2不相等。 接着下面 t3 = new String(“2”) + new String(“2”); 这段代码调用之前，字符串常量池有一个”2”的对象，执行之后，实际上会调用StringBuilder的append()方法类进行拼接，最后在堆中创建一个”22”的对象，注意，此时字面量并没有”22”这个字符串，也就是说在字符串常量池并没有”22”这个对象。此时t3指向堆中”22”这个对象 t3.intern(); 执行这个方法之后 在JDK1.6的时候，它在字符串常量池中并没有找到内容为”22”的对象，所以这个时候会把这个对象添加到字符串常量池，并把这个对象返回(此时并没有变量来接收这个返回的对象)。注意添加的是对象，而并非引用。 t4 = “22”。 这句代码执行后，会返回字符串常量池中内容为”22”对象，此时t4指向的是字符串常量池中的对象。 显然，一个对象在字符串常量池，一个在堆中，两个对象并非是同一个对象，因此在JDK1.6的时候，t3与t4不相等。 但是在JDK1.7的时候 t3.intern()执行之后，由于在字符串常量池在并没有内容为”22”的对象，所以会把堆中该对象的引用赋值到字符串常量池。注意此时字符串常量池保存的是堆中这个对象的引用。 t4 = “22”。 执行这句代码之后，从字符串常量池返回给t4的是堆中对象的引用。此时t4指向的实际上是堆中对象的引用，也就是说，t3和t4指向的是同一个对象。 因此t3与t4相等。 不知道你明白了没有？反正我是搞了好久才明白… 问题2至于问题2，我就只讲下半部分的代码，上半部分如果你看懂了问题1，那么问题2也差不多自然懂了。 1234String t3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);String t4 = &quot;22&quot;;t3.intern();System.out.println(t3 == t4); t3 = new String(“2”) + new String(“2”)。 这段代码调用之前，字符串常量池有一个”2”的对象，执行之后，实际上会调用StringBuilder的append()方法类进行拼接，最后在堆中创建一个”22”的对象。此时t3指向堆中”22”这个对象 t4 = “22”。 这句代码执行之前，字符串常量池已经存在”22”这个对象了，所有直接把这个对象返回给t4，此时t4指向的是字符串常量池中的对象. 所以t3和t4肯定不是同一个对象啊，t3.intern这句几乎可以忽略，不会给t3和t4造成任何影响。 问题312345678910111213141516public static void main(String[] args)&#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; System.out.println(c == d); System.out.Println(e == f); System.out.println(c == (a + b)); System.out.println(c.equals(a+b)); System.out.println(g == (a + b)); System.out.println(g.equals(a + b));&#125; 对于这个问题，我简单说一下可能你就懂了。 (1). 内存中有一个java基本类型封装类的常量池。这些类包括Byte, Short, Integer, Long, Character, Boolean。需要注意的是，Float和Double这两个类并没有对应的常量池。 (2).上面5种整型的包装类也只是在对象数值在-128~127才可以使用这些常量池。 (3). 在周志明的那本虚拟机中有这样一句话：包装类的“\==”运行符在不遇到算术运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据类型的关系，可以推断出如果遇到“==”两边有算术运算是话就会自动拆箱和进行数据类型转换处理。 (4).Long的equals方法会先判断是否是Long类型。 (5).无论是Integer还是Long，他们的equals方法比较的是数值。 所以： System.out.println(c == d)。 由于常量池的作用，c与d指向的是同一个对象(注意此时的==比较的是对象，也就是地址，而不是数值)。因此为true System.out.println(e == f)。 由于321超过了127，因此常量池失去了作用，所以e和f数值虽然相同，但不是同一个对象，以此为false。 System.out.println(c == (a+b))。 此时==两边有算术运算，会进行拆箱，因此此时比较的是数值，而并非对象。因此为true。 System.out.println(c.equals(a+b)) c与a+b的数值相等，为true。 System.out.pirnln(g == (a + b)) 由于==两边有算术运算，所以比较的是数值，因此为true。 System.out.println(g.equals(a+b))。 Long类型的equal在比较是时候，会先判断a+b是否为Long类型，显然a+b不是，因此false 问题到此就结束了，以上便是自己的理解，以上如果有不对劲的地方，非常欢迎你的指点。 完。 关注公众号「苦逼的码农」，获取更多原创文章，后台回复「礼包」送你一份特别的大礼包]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
